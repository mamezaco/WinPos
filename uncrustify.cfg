#クラスト化解除-0.68.1

#
#一般的なオプション
#

#行末のタイプ。
#
#デフォルト：自動
newlines = crlf	#lf / crlf / cr / auto

#入力のタブの元のサイズ。
#
#デフォルト：8
input_tab_size = 4	#符号なしの数値

#出力内のタブのサイズ（align_with_tabs = trueの場合にのみ使用されます）。
#
#デフォルト：8
output_tab_size = 4	#符号なしの数値

#文字列エスケープ文字のASCII値。通常は92（\）または（Pawn）94（^）です。
#
#デフォルト：92
string_escape_char = 92	#符号なしの数値

#代替文字列エスケープ文字（通常はポーンにのみ使用されます）。
#引用文字の直前でのみ機能します。
string_escape_char2 = 0	#符号なしの数値

#文字列リテラルで見つかったタブ文字をエスケープシーケンスに置き換えます\ t
#代わりに。
string_replace_tab_chars = true	#true / false

#「> =」と「>> =」を次のようなコードのテンプレートの一部として解釈できるようにする
# 'void f（list <list <B >> = val）;'。trueの場合、 'assert（x <0 && y> = 3）'は壊れます。
#テンプレート検出の改善により、このオプションが廃止される可能性があります。
tok_split_gte = false	#true / false

#コメントで使用されるマーカーを指定して、一部の処理を無効にします
#ファイル。
#
#デフォルト：*インデントオフ*
disable_processing_cmt = "* INDENT-OFF *"	#文字列

#ファイルでの処理を（再）有効にするためにコメントで使用されるマーカーを指定します。
#
#デフォルト：*インデントオン*
enable_processing_cmt = "* INDENT-ON *"	#文字列

#有向グラフの解析を有効にします。
enable_digraphs = false	#true / false

#UTF-8 BOMを追加または削除します（「削除」を推奨）。
utf8_bom = ignore	#ignore / add / remove / force

#ファイルに128?255の値のバイトが含まれているが、含まれていない場合
#UTF-8、次にUTF-8として出力します。
utf8_byte = false	#true / false

#出力エンコーディングをUTF-8に強制します。
utf8_force = false	#true / false

#
#間隔オプション
#

#非割り当てシンボリック演算子（ '+'、 '/'、 '％'、
# '<<'など）。
sp_arith = add	#ignore / add / remove / force

#算術演算子「+」および「-」の周囲のスペースを追加または削除します。
#
#sp_arithをオーバーライドします。
sp_arith_additive = add	#ignore / add / remove / force

#代入演算子 '='、 '+ ='などの周囲のスペースを追加または削除します。
sp_assign = add	#ignore / add / remove / force

#C ++ 11ラムダキャプチャ仕様の「=」の前後のスペースを追加または削除します。
#
#sp_assignをオーバーライドします。
sp_cpp_lambda_assign = add	#ignore / add / remove / force

#C ++ 11ラムダのキャプチャ仕様の後にスペースを追加または削除します。
sp_cpp_lambda_paren = add	#ignore / add / remove / force

#プロトタイプの代入演算子 '='の周囲のスペースを追加または削除します。
sp_assign_default = add	#ignore / add / remove / force

#代入演算子 '='、 '+ ='などの前にスペースを追加または削除します。
#
#sp_assignをオーバーライドします。
sp_before_assign = force	#無視/追加/削除/強制

#代入演算子 '='、 '+ ='などの後にスペースを追加または削除します。
#
#sp_assignをオーバーライドします。
sp_after_assign = force	#ignore / add / remove / force

# 'NS_ENUM（'のスペースを追加または削除します。
sp_enum_paren = add	# を追加!!!! 無視/追加/削除/強制

#列挙型の代入 '='の周囲のスペースを追加または削除します。
sp_enum_assign = add	#ignore / add / remove / force

#列挙型の代入 '='の前にスペースを追加または削除します。
#
#sp_enum_assignをオーバーライドします。
sp_enum_before_assign = add	#ignore / add / remove / force

#列挙型の代入 '='の後にスペースを追加または削除します。
#
#sp_enum_assignをオーバーライドします。
sp_enum_after_assign = add	#ignore / add / remove / force

#列挙型の代入 '：'の周囲のスペースを追加または削除します。
sp_enum_colon = add	#ignore / add / remove / force

#プリプロセッサ ' 	# 	#'連結演算子の周囲のスペースを追加または削除します。
#
#デフォルト：追加
sp_pp_concat = add	#ignore / add / remove / force

#プリプロセッサ '	#' stringify演算子の後にスペースを追加または削除します。
#「	#@」charizing演算子にも影響します。
sp_pp_stringify = add	#!!!! 無視/追加/削除/強制

#プリプロセッサの前にスペースを追加または削除する '	#' stringify演算子
# '	#define x（y）L	#y'のように。
sp_before_pp_stringify = add	#!!!! 無視/追加/削除/強制

#ブール演算子「&&」および「||」の周囲のスペースを追加または削除します。
sp_bool = add	#ignore / add / remove / force

#比較演算子 '<'、 '>'、 '=='などの周囲のスペースを追加または削除します。
sp_compare = add	#ignore / add / remove / force

# '（'および '）'内のスペースを追加または削除します。
sp_inside_paren = remove	#ignore / add / remove / force

#ネストされた括弧の間にスペースを追加または削除します。つまり、 '（（' vs. '））'です。
sp_paren_paren = remove	#!!!! 無視/追加/削除/強制

#連続する括弧の間のスペースを追加または削除します。つまり、 '）（' vs。 '）（'。
sp_cparen_oparen = remove	#!!!! 無視/追加/削除/強制

#ネストされた括弧内のスペースのバランスを取るかどうか。
sp_balance_nested_parens = false	#!!!! 真/偽

#「）」と「{」の間のスペースを追加または削除します。
sp_paren_brace = add	#!!!! 無視/追加/削除/強制

#ネストされた中括弧の間にスペースを追加または削除します。つまり、 '{
#		{' vs '{
#				{'。
sp_brace_brace = add	#!!!! 無視/追加/削除/強制

#ポインタスター '*'の前にスペースを追加または削除します。
sp_before_ptr_star = add	#ignore / add / remove / force

#ポインタスター '*'の前にスペースを追加または削除します。
#変数名。'ignore'に設定すると、代わりにsp_before_ptr_starが使用されます。
sp_before_unnamed_ptr_star = add	#ignore / add / remove / force

#ポインタの星「*」の間のスペースを追加または削除します。
sp_between_ptr_star = remove	#ignore / add / remove / force

#単語が続く場合は、ポインタスター「*」の後にスペースを追加または削除します。
sp_after_ptr_star = remove	#ignore / add / remove / force

#単語が続く場合は、ポインタキャレット '^'の後にスペースを追加または削除します。
sp_after_ptr_block_caret = ignore	#ignore / add / remove / force

#修飾子が後に続く場合は、ポインタースター '*'の後にスペースを追加または削除します。
sp_after_ptr_star_qualifier = remove	#!!!! 無視/追加/削除/強制

#関数が後に続く場合は、ポインタスター '*'の後にスペースを追加または削除します
#プロトタイプまたは関数の定義。
sp_after_ptr_star_func = remove	#ignore / add / remove / force

#ポインタスター '*'の後にスペースを追加または削除し、その後にオープンが続く場合
#括弧 'void *（*）（）のように。
sp_ptr_star_paren = ignore	#ignore / add / remove / force

#関数が後に続く場合は、ポインタスター「*」の前にスペースを追加または削除します
#プロトタイプまたは関数の定義。
sp_before_ptr_star_func = add	#ignore / add / remove / force

#リファレンス記号「＆」の前のスペースを追加または削除します。
sp_before_byref = ignore	#ignore / add / remove / force

#参照記号 '＆'の前にスペースを追加または削除します。
#変数名。'ignore'に設定すると、代わりにsp_before_byrefが使用されます。
sp_before_unnamed_byref = ignore	#ignore / add / remove / force

#単語が続く場合は、リファレンス記号「＆」の後にスペースを追加または削除します。
sp_after_byref = ignore	#ignore / add / remove / force

#関数が後に続く場合は、リファレンス記号 '＆'の後にスペースを追加または削除します
#プロトタイプまたは関数の定義。
sp_after_byref_func = ignore	#ignore / add / remove / force

#関数が後に続く場合は、リファレンス記号「＆」の前にスペースを追加または削除します
#プロトタイプまたは関数の定義。
sp_before_byref_func = ignore	#ignore / add / remove / force

#タイプと単語の間にスペースを追加または削除します。
#
#デフォルト：force
sp_after_type = force	#ignore / add / remove / force

# 'decltype（...）'とwordの間にスペースを追加または削除します。
sp_after_decltype = ignore	#ignore / add / remove / force

#（D）Dコンストラクトの括弧の前にスペースを追加または削除します
# 'テンプレートFoo（'および 'クラスFoo（'。
sp_before_template_paren = ignore	#ignore / add / remove / force

#「テンプレート」と「<」の間にスペースを追加または削除します。
#無視するように設定されている場合、sp_before_angleが使用されます。
sp_template_angle = ignore	#ignore / add / remove / force

#「<」の前のスペースを追加または削除します。
sp_before_angle = ignore	#ignore / add / remove / force

#「<」および「>」内のスペースを追加または削除します。
sp_inside_angle = ignore	#ignore / add / remove / force

#「>」と「：」の間のスペースを追加または削除します。
sp_angle_colon = ignore	#ignore / add / remove / force

#「<>」の後にスペースを追加または削除します。
sp_after_angle = ignore	#ignore / add / remove / force

#「newList <byte>（foo）;」にある「>」と「（」の間のスペースを追加または削除します。
sp_angle_paren = ignore	#ignore / add / remove / force

#「newList <byte>（）;」にある「>」と「（）」の間のスペースを追加または削除します。
sp_angle_paren_empty = ignore	#ignore / add / remove / force

#「List <byte> m;」のように、「>」と単語の間にスペースを追加または削除します。または
# 'テンプレート<typenameT> static ...'。
sp_angle_word = ignore	#ignore / add / remove / force

#「>>」（テンプレートのもの）の「>」と「>」の間のスペースを追加または削除します。
#
#デフォルト：追加
sp_angle_shift = add	#ignore / add / remove / force

#（C ++ 11） 'foo <bar <int >>'の '>>'間のスペースの削除を許可します。注意
#sp_angle_shiftは、このオプションがないとスペースを削除できません。
sp_permit_cpp11_shift = false	#true / false

#制御ステートメントの '（'の前にスペースを追加または削除します（ 'if'、 'for'、 'switch'、
# 'while'など）。
sp_before_sparen = add	#ignore / add / remove / force

#制御ステートメントの '（'および '）'内のスペースを追加または削除します。
sp_inside_sparen = remove	#ignore / add / remove / force

#制御ステートメントの '（'の後にスペースを追加または削除します。
#
#sp_inside_sparenをオーバーライドします。
sp_inside_sparen_open = ignore	#ignore / add / remove / force

#制御ステートメントの「）」の前にスペースを追加または削除します。
#
#sp_inside_sparenをオーバーライドします。
sp_inside_sparen_close = ignore	#ignore / add / remove / force

#制御ステートメントの「）」の後にスペースを追加または削除します。
sp_after_sparen = add	#を追加!!!! 無視/追加/削除/強制

#制御ステートメントの「）」と「{」の間のスペースを追加または削除します。
sp_sparen_brace = add	#!!!! 無視/追加/削除/強制

#（D）「不変」と「（」の間のスペースを追加または削除します。
sp_invariant_paren = ignore	#ignore / add / remove / force

#（D）「不変（C）c」の「）」の後にスペースを追加または削除します。
sp_after_invariant_paren = ignore	#ignore / add / remove / force

#空のステートメントの前にスペースを追加または削除します ';' 「if」、「for」、「while」。
sp_special_semi = ignore	#ignore / add / remove / force

#「;」の前にスペースを追加または削除します。
#
#デフォルト：削除
sp_before_semi = remove	#ignore / add / remove / force

#「;」の前にスペースを追加または削除します 空でない 'for'ステートメント。
sp_before_semi_for = remove	#!!!! 無視/追加/削除/強制

#forステートメントの空の部分のセミコロンの前にスペースを追加または削除します。
sp_before_semi_for_empty = remove	#!!!! 無視/追加/削除/強制

#コメントが続く場合を除いて、「;」の後にスペースを追加または削除します。
#
#デフォルト：追加
sp_after_semi = add	#ignore / add / remove / force

# ';'の後にスペースを追加または削除します 空でない 'for'ステートメント。
#
#デフォルト：force
sp_after_semi_for = force	#無視/追加/削除/強制

#forの空の部分の最後のセミコロンの後にスペースを追加または削除します
#ステートメント、 'for（;; <here>）'のように。
sp_after_semi_for_empty = remove	#!!!! 無視/追加/削除/強制

#「[」の前にスペースを追加または削除します（「[]」を除く）。
sp_before_square = remove	#!!!! 無視/追加/削除/強制

#「[]」の前にスペースを追加または削除します。
sp_before_squares = remove	#!!!! 無視/追加/削除/強制

#C ++ 17構造化バインディングの前にスペースを追加または削除します。
sp_cpp_before_struct_binding = ignore	#ignore / add / remove / force

#空でない '['および '
#							]'内のスペースを追加または削除します。
sp_inside_square = remove	#!!!! 無視/追加/削除/強制

#（OC）空でないObjective-Cボックス配列内のスペースを追加または削除する '@ ['および
# '
#							]'。無視するように設定されている場合、sp_inside_squareが使用されます。
sp_inside_square_oc_array = ignore	#ignore / add / remove / force

#「、」の後にスペースを追加または削除します。つまり、「a、b」と「a、b」を比較します。
sp_after_comma = force	#ignore / add / remove / force

#「、」の前にスペースを追加または削除します。
#
#デフォルト：削除
sp_before_comma = remove	#ignore / add / remove / force

#（C	#）多次元配列型の「、」、「
#						]」の間のスペースを追加または削除します
# 'int [
#							,
#							,
#						]'のように。
sp_after_mdatype_commas = ignore	#ignore / add / remove / force

#（C	#）多次元配列型の「[」と「、」の間のスペースを追加または削除します
# 'int [
#								,
#								,
#							]'のように。
sp_before_mdatype_commas = ignore	#ignore / add / remove / force

#（C	#）多次元配列型の「、」間のスペースを追加または削除します
# 'int [
#								,
#								,
#							]'のように。
sp_between_mdatype_commas = ignore	#ignore / add / remove / force

#開き括弧とカンマの間にスペースを追加または削除し、
#すなわち '（、' vs。 '（、'。
#
#デフォルト：force
sp_paren_comma = force	#ignore / add / remove / force

#前にaが付いている場合、可変個引数「...」の前にスペースを追加または削除します
#非パンクチャ。
sp_before_ellipsis = ignore	#ignore / add / remove / force

#タイプと「...」の間にスペースを追加または削除します。
sp_type_ellipsis = ignore	#ignore / add / remove / force

#「）」と「...」の間のスペースを追加または削除します。
sp_paren_ellipsis = ignore	#ignore / add / remove / force

#クラス '：'の後にスペースを追加または削除します。
sp_after_class_colon = ignore	#ignore / add / remove / force

#クラス '：'の前にスペースを追加または削除します。
sp_before_class_colon = ignore	#ignore / add / remove / force

#クラスコンストラクタ '：'の後にスペースを追加または削除します。
sp_after_constr_colon = ignore	#ignore / add / remove / force

#クラスコンストラクタ '：'の前にスペースを追加または削除します。
sp_before_constr_colon = ignore	#ignore / add / remove / force

#ケース '：'の前にスペースを追加または削除します。
#
#デフォルト：削除
sp_before_case_colon = remove	#ignore / add / remove / force

#「演算子」と演算子記号の間のスペースを追加または削除します。
sp_after_operator = add	#を追加!!!! 無視/追加/削除/強制

#演算子記号と開き括弧の間にスペースを追加または削除します。
#in '演算子++（'。
sp_after_operator_sym = add	#!!!! 無視/追加/削除/強制

#演算子に引数がない場合は、sp_after_operator_symをオーバーライドします。
# '演算子*（）'。
sp_after_operator_sym_empty = ignore	#ignore / add / remove / force

#C / Dキャストの後にスペースを追加または削除します。つまり、「cast（int）a」と「cast（int）a」または
# '（int）a' vs。 '（int）a'。
sp_after_cast = remove	#!!!! 無視/追加/削除/強制

#キャスト括弧内のスペースを追加または削除します。
sp_inside_paren_cast = remove	#!!!! 無視/追加/削除/強制

#C ++キャストで、型と開き括弧の間にスペースを追加または削除します。
#すなわち、「int（exp）」と「int（exp）」。
sp_cpp_cast_paren = ignore	#ignore / add / remove / force

# 'sizeof'と '（'の間のスペースを追加または削除します。
sp_sizeof_paren = remove	#ignore / add / remove / force

#「sizeof」と「...」の間のスペースを追加または削除します。
sp_sizeof_ellipsis = remove	#!!!! 無視/追加/削除/強制

#「sizeof ...」と「（」の間のスペースを追加または削除します。
sp_sizeof_ellipsis_paren = remove	#ignore / add / remove / force

#「decltype」と「（」の間にスペースを追加または削除します。
sp_decltype_paren = ignore	#ignore / add / remove / force

#（ポーン）tagキーワードの後に??スペースを追加または削除します。
sp_after_tag = ignore	#ignore / add / remove / force

#列挙型 '{'および '}'内のスペースを追加または削除します。
sp_inside_braces_enum = ignore	#ignore / add / remove / force

#struct / union '{'および '
#							}'内のスペースを追加または削除します。
sp_inside_braces_struct = ignore	#ignore / add / remove / force

#（OC）Objective-Cボックス辞書 '{'および '
#							}'内のスペースを追加または削除します
sp_inside_braces_oc_dict = ignore	#ignore / add / remove / force

#名前のない一時的な中括弧を開いた後、スペースを追加または削除します
#direct-list-initialization。
sp_after_type_brace_init_lst_open = ignore	#ignore / add / remove / force

#名前のない一時的な中括弧を閉じる前にスペースを追加または削除します
#direct-list-initialization。
sp_before_type_brace_init_lst_close = ignore	#ignore / add / remove / force

#名前のない一時的なdirect-list-initialization内のスペースを追加または削除します。
sp_inside_type_brace_init_lst = ignore	#ignore / add / remove / force

#「{」および「}」内のスペースを追加または削除します。
sp_inside_braces = add	#!!!! 無視/追加/削除/強制

#「{}」内のスペースを追加または削除します。
sp_inside_braces_empty = remove	#!!!! 無視/追加/削除/強制

#戻り値の型と関数名の間のスペースを追加または削除します。最小1
#ポインタの戻り値の型を除いて強制されます。
sp_type_func = force	#ignore / add / remove / force

#名前のない一時的な中括弧のタイプと中括弧の間にスペースを追加または削除します
#direct-list-initialization。
sp_type_brace_init_lst = ignore	#ignore / add / remove / force

#関数宣言の関数名と '（'の間のスペースを追加または削除します。
sp_func_proto_paren = remove	#ignore / add / remove / force

#関数宣言で関数名と「（）」の間にスペースを追加または削除します
#パラメータなし。
sp_func_proto_paren_empty = remove	#無視/追加/削除/強制

#関数名と関数定義の「（」の間のスペースを追加または削除します。
sp_func_def_paren = remove	#ignore / add / remove / force

#関数定義の関数名と「（）」の間にスペースを追加または削除します
#パラメータなし。
sp_func_def_paren_empty = remove	#ignore / add / remove / force

#空関数 '（）'内のスペースを追加または削除します。
sp_inside_fparens = remove	#ignore / add / remove / force

#関数 '（'および '）'内のスペースを追加または削除します。
sp_inside_fparen = remove	#ignore / add / remove / force

#関数型の最初の括弧内のスペースを追加または削除します。
# 'void（* x）（...）'。
sp_inside_tparen = remove	#ignore / add / remove / force

#関数型の「）」と「（」の間にスペースを追加または削除します。
# 'void（* x）（...）'。
sp_after_tparen_close = remove	#ignore / add / remove / force

#関数呼び出しの一部である場合、 '
#						]'と '（'の間のスペースを追加または削除します。
sp_square_fparen = ignore	#ignore / add / remove / force

#関数の「）」と「{」の間のスペースを追加または削除します。
sp_fparen_brace = ignore	#ignore / add / remove / force

#オブジェクト内の関数呼び出しの「）」と「{」の間のスペースを追加または削除します
#初期化。
#
#sp_fparen_braceをオーバーライドします。
sp_fparen_brace_initializer = ignore	#ignore / add / remove / force

#（Java）二重中括弧初期化子の「）」と「{{」の間のスペースを追加または削除します。
sp_fparen_dbrace = ignore	#ignore / add / remove / force

#関数呼び出しで関数名と「（」の間にスペースを追加または削除します。
sp_func_call_paren = remove	#ignore / add / remove / force

#関数名と「（）」の間にスペースを追加または削除します。
# パラメーター。'ignore'（デフォルト）に設定すると、sp_func_call_parenが使用されます。
sp_func_call_paren_empty = remove	#ignore / add / remove / force

#ユーザー関数名と関数の「（」の間のスペースを追加または削除します
#呼び出し。設定ファイルでキーワードをユーザー関数に設定する必要があります。
# お気に入り：
#func_call_user tr _i18nを設定します
sp_func_call_user_paren = remove	#!!!! 無視/追加/削除/強制

#ユーザー関数 '（'および '）'内のスペースを追加または削除します。
sp_func_call_user_inside_fparen = remove	#ignore / add / remove / force

#ユーザー関数を使用して、ネストされた括弧の間にスペースを追加または削除します。
#ie '（（' vs。 '（（'。
sp_func_call_user_paren_paren = remove	#!!!! 無視/追加/削除/強制

#コンストラクタ/デストラクタとオープンの間のスペースを追加または削除します
#括弧。
sp_func_class_paren = ignore	#ignore / add / remove / force

#パラメータまたはデストラクタのないコンストラクタ間のスペースを追加または削除します
#および '（）'。
sp_func_class_paren_empty = ignore	#ignore / add / remove / force

#「return」と「（」の間にスペースを追加または削除します。
sp_return_paren = ignore	#ignore / add / remove / force

#「return」と「{」の間にスペースを追加または削除します。
sp_return_brace = ignore	#ignore / add / remove / force

#「__ attribute__」と「（」の間のスペースを追加または削除します。
sp_attribute_paren = ignore	#ignore / add / remove / force

#「	#if defined（FOO）」の「defined」と「（」の間のスペースを追加または削除します。
sp_defined_paren = ignore	#ignore / add / remove / force

#「throw（something）」の「throw」と「（」の間にスペースを追加または削除します。
sp_throw_paren = remove	#!!!! 無視/追加/削除/強制

#「throw」と「（」以外のものの間のスペースを追加または削除します。
# '@ throw [...
											];'。
sp_after_throw = ignore	#ignore / add / remove / force

#「catch（something）{}」の「catch」と「（」の間のスペースを追加または削除します。
#無視するように設定されている場合、sp_before_sparenが使用されます。
sp_catch_paren = ignore	#ignore / add / remove / force

#（OC） '@ catch'と '（'の間のスペースを追加または削除します
#in '@ catch（something）{}'。無視するように設定されている場合、sp_catch_parenが使用されます。
sp_oc_catch_paren = ignore	#ignore / add / remove / force

#（D）「バージョン」と「（」の間のスペースを追加または削除します
#バージョン（何か）{} '。無視するように設定されている場合、sp_before_sparenが使用されます。
sp_version_paren = ignore	#ignore / add / remove / force

#（D） 'scope'と '（'の間のスペースを追加または削除します
#スコープ（何か）{} '。無視するように設定されている場合、sp_before_sparenが使用されます。
sp_scope_paren = ignore	#ignore / add / remove / force

#「super（something）」の「super」と「（」の間のスペースを追加または削除します。
#
#デフォルト：削除
sp_super_paren = remove	#ignore / add / remove / force

#「this（something）」の「this」と「（」の間のスペースを追加または削除します。
#
#デフォルト：削除
sp_this_paren = remove	#ignore / add / remove / force

#マクロ名とその定義の間にスペースを追加または削除します。
sp_macro = add	#!!!! 無視/追加/削除/強制

#マクロ関数 '）'とその定義の間にスペースを追加または削除します。
sp_macro_func = add	#!!!! 無視/追加/削除/強制

#同じ行にある場合は、「else」と「{」の間にスペースを追加または削除します。
sp_else_brace = add	#ignore / add / remove / force

#同じ行にある場合は、「}」と「else」の間にスペースを追加または削除します。
sp_brace_else = add	#を追加!!!! 無視/追加/削除/強制

#同じ行の「}」とtypedefの名前の間にスペースを追加または削除します。
sp_brace_typedef = ignore	#ignore / add / remove / force

#「{」と「catch」ステートメントの「{」の前にスペースを追加または削除する
# 'catch'は、 'catch（decl）<here> {'のように、同じ行にあります。
sp_catch_brace = ignore	#ignore / add / remove / force

#（OC） '{'の場合、 '@ catch'ステートメントの '{'の前にスペースを追加または削除します
#と '@catch'は、 '@ catch（decl）<here> {'のように、同じ行にあります。
#無視するように設定されている場合、sp_catch_braceが使用されます。
sp_oc_catch_brace = ignore	#ignore / add / remove / force

#同じ行にある場合は、「}」と「catch」の間にスペースを追加または削除します。
sp_brace_catch = ignore	#ignore / add / remove / force

#（OC）同じ行にある場合は、「}」と「@catch」の間にスペースを追加または削除します。
#無視するように設定されている場合、sp_brace_catchが使用されます。
sp_oc_brace_catch = ignore	#ignore / add / remove / force

#同じ行にある場合は、「finally」と「{」の間にスペースを追加または削除します。
sp_finally_brace = ignore	#ignore / add / remove / force

#同じ行にある場合は、「}」と「finally」の間にスペースを追加または削除します。
sp_brace_finally = ignore	#ignore / add / remove / force

#同じ行にある場合は、「try」と「{」の間にスペースを追加または削除します。
sp_try_brace = ignore	#ignore / add / remove / force

#同じ行にある場合は、get / setと「{」の間にスペースを追加または削除します。
sp_getset_brace = ignore	#ignore / add / remove / force

#C ++ユニフォームの場合、変数と「{」の間にスペースを追加または削除します
#初期化。
#
#デフォルト：追加
sp_word_brace = add	#ignore / add / remove / force

#変数と名前空間の「{」の間にスペースを追加または削除します。
#
#デフォルト：追加
sp_word_brace_ns = add	#ignore / add / remove / force

#「: :」演算子の前にスペースを追加または削除します。
sp_before_dc = remove	#ignore / add / remove / force

# ': :'演算子の後にスペースを追加または削除します。
sp_after_dc = remove	#ignore / add / remove / force

#（D）D名前付き配列初期化子 '：'演算子の周囲を追加または削除します。
sp_d_array_colon = ignore	#ignore / add / remove / force

#「！」の後にスペースを追加または削除します （ではない）単項演算子。
#
#デフォルト：削除
sp_not = remove	#ignore / add / remove / force

#「?」（反転）単項演算子の後にスペースを追加または削除します。
#
#デフォルト：削除
sp_inv = remove	#ignore / add / remove / force

#「＆」（アドレスの）単項演算子の後にスペースを追加または削除します。これはしません
#型の一部である「＆」の後の間隔に影響します。
#
#デフォルト：削除
sp_addr = remove	#ignore / add / remove / force

#「。」の周りのスペースを追加または削除します。または '->'演算子。
#
#デフォルト：削除
sp_member = remove	#ignore / add / remove / force

#「*」（逆参照）単項演算子の後にスペースを追加または削除します。これはします
#型の一部である「*」の後の間隔には影響しません。
#
#デフォルト：削除
sp_deref = remove	#ignore / add / remove / force

#「x = -5」または「y = +7」のように、「+」または「-」の後にスペースを追加または削除します。
#
#デフォルト：削除
sp_sign = remove	#ignore / add / remove / force

#「++」と「-」の間にスペースを追加または削除します
#「（-x）」または「y ++;」のように適用されます。
#
#デフォルト：削除
sp_incdec = remove	#ignore / add / remove / force

#行末のバックスラッシュ改行の前にスペースを追加または削除します。
#
#デフォルト：追加
sp_before_nl_cont = add	#ignore / add / remove / force

#（OC） '-（void）foo;'のように、スコープ '+'または '-'の後にスペースを追加または削除します。
#または '+（int）bar;'。
sp_after_oc_scope = add	#を追加!!!! 無視/追加/削除/強制

#（OC）メッセージ仕様のコロンの後にスペースを追加または削除します。
#ie '-（int）f：（int）x;' vs .'-（int）f：（int）x; '。
sp_after_oc_colon = ignore	#ignore / add / remove / force

#（OC）メッセージ仕様のコロンの前のスペースを追加または削除します。
#ie '-（int）f：（int）x;' vs .'-（int）f：（int）x; '。
sp_before_oc_colon = ignore	#ignore / add / remove / force

#（OC）不変の辞書式のコロンの後にスペースを追加または削除する
# 'NSDictionary * test = @ {@ "foo"：@ "bar"};'。
sp_after_oc_dict_colon = ignore	#ignore / add / remove / force

#（OC）不変の辞書式でコロンの前のスペースを追加または削除します
# 'NSDictionary * test = @ {@ "foo"：@ "bar"};'。
sp_before_oc_dict_colon = ignore	#ignore / add / remove / force

#（OC）メッセージ仕様のコロンの後にスペースを追加または削除します。
#ie '[object setValue：1];' vs。 '[object setValue：1];'。
sp_after_send_oc_colon = ignore	#ignore / add / remove / force

#（OC）メッセージ仕様のコロンの前のスペースを追加または削除します。
#ie '[object setValue：1];' vs。 '[object setValue：1];'。
sp_before_send_oc_colon = ignore	#ignore / add / remove / force

#（OC）メッセージ仕様の（タイプ）の後にスペースを追加または削除します。
#ie '-（int）f：（int）x;' vs .'-（int）f：（int）x; '。
sp_after_oc_type = ignore	#ignore / add / remove / force

#（OC）メッセージ仕様の最初の（タイプ）の後にスペースを追加または削除します。
#ie '-（int）f：（int）x;' vs .'-（int）f：（int）x; '。
sp_after_oc_return_type = ignore	#ignore / add / remove / force

#（OC）「@ selector」と「（」の間のスペースを追加または削除します。
#すなわち「@selector（msgName）」と「@selector（msgName）」。
# '@ protocol（）'構造にも適用されます。
sp_after_oc_at_sel = ignore	#ignore / add / remove / force

#（OC） '@ selector（x）'と次の単語の間のスペースを追加または削除します。
#すなわち '@selector（foo）a：' vs。 '@ selector（foo）a：'。
sp_after_oc_at_sel_parens = ignore	#ignore / add / remove / force

#（OC） '@ selector'括弧内のスペースを追加または削除します。
#すなわち「@selector（foo）」と「@selector（foo）」。
# '@ protocol（）'構造にも適用されます。
sp_inside_oc_at_sel_parens = ignore	#ignore / add / remove / force

#（OC）ブロックポインタキャレットの前にスペースを追加または削除します。
#ie '^ int（int arg）{...}' vs。 '^ int（int arg）{...}'。
sp_before_oc_block_caret = ignore	#ignore / add / remove / force

#（OC）ブロックポインタキャレットの後にスペースを追加または削除します。
#ie '^ int（int arg）{...}' vs。 '^ int（int arg）{...}'。
sp_after_oc_block_caret = ignore	#ignore / add / remove / force

#（OC）メッセージ内のレシーバーとセレクターの間のスペースを追加または削除します。
#「[レシーバーセレクター...	]」のように。
sp_after_oc_msg_receiver = ignore	#ignore / add / remove / force

#（OC）「@ property」の後にスペースを追加または削除します。
sp_after_oc_property = ignore	#ignore / add / remove / force

#（OC）「@ synchronized」と開き括弧の間にスペースを追加または削除します。
#すなわち「@synchronized（foo）」と「@synchronized（foo）」。
sp_after_oc_synchronized = ignore	#ignore / add / remove / force

# 'bの'： 'の周りのスペースを追加または削除しますか？t：f '。
sp_cond_colon = ignore	#ignore / add / remove / force

# 'bの'： 'の前にスペースを追加または削除しますか？t：f '。
#
#sp_cond_colonをオーバーライドします。
sp_cond_colon_before = ignore	#ignore / add / remove / force

# 'bの'： 'の後にスペースを追加または削除しますか？t：f '。
#
#sp_cond_colonをオーバーライドします。
sp_cond_colon_after = ignore	#ignore / add / remove / force

#「？」の周りのスペースを追加または削除します 'b？t：f '。
sp_cond_question = add	#!!!! 無視/追加/削除/強制

#「？」の前にスペースを追加または削除します 'b？t：f '。
#
#sp_cond_questionをオーバーライドします。
sp_cond_question_before = remove	#ignore / add / remove / force

#「？」の後にスペースを追加または削除します 'b？t：f '。
#
#sp_cond_questionをオーバーライドします。
sp_cond_question_after = ignore	#ignore / add / remove / force

#省略形の三部形式 '（a？：b）'で、 '？'の間にスペースを追加または削除します。
#および '：'。
#
#他のすべてのsp_cond_ *オプションをオーバーライドします。
sp_cond_ternary_short = ignore	#ignore / add / remove / force

#「case」とラベルの間の間隔を修正します。'ignore'と 'force'のみが作成されます
#ここでセンス。
sp_case_label = ignore	#ignore / add / remove / force

#（D）D '..'演算子の周囲のスペースを追加または削除します。
sp_range = ignore	#ignore / add / remove / force

#Java / C ++ 11範囲ベースの 'for'の '：'の後にスペースを追加または削除します。
# 'for（Type var：expr）'のように。
sp_after_for_colon = ignore	#ignore / add / remove / force

#Java / C ++ 11範囲ベースの 'for'の '：'の前にスペースを追加または削除します。
# 'for（Type var：expr）'のように。
sp_before_for_colon = ignore	#ignore / add / remove / force

#（D）「extern（C）」のように「extern」と「（」の間にスペースを追加または削除します。
sp_extern_paren = ignore	#ignore / add / remove / force

#C ++コメントを開いた後、スペースを追加または削除します。
#すなわち ' // A'対 '// A'。
sp_cmt_cpp_start = ignore	#ignore / add / remove / force

#trueの場合、スペースはsp_cmt_cpp_startで追加され、doxygenの後に追加されます
# ' ///'、 '/// <'、 '//！'のようなシーケンス および '//！<'。
sp_cmt_cpp_doxygen = false	#true / false

#trueの場合、スペースはsp_cmt_cpp_startで追加され、Qtの後に追加されます
#「 //：」、「// =」、「//?」などの翻訳者またはメタデータのコメント。
sp_cmt_cpp_qttr = false	#true / false

#	# elseまたは	#endifと末尾のコメントの間のスペースを追加または削除します。
sp_endif_cmt = ignore	#ignore / add / remove / force

#「new」、「delete」、「delete []」の後にスペースを追加または削除します。
sp_after_new = ignore	#ignore / add / remove / force

#「new（）」の「new」と「（」の間のスペースを追加または削除します。
sp_between_new_paren = ignore	#ignore / add / remove / force

#「）」の間にスペースを追加または削除し、「new（foo）BAR」と入力します。
sp_after_newop_paren = ignore	#ignore / add / remove / force

#新しい演算子の括弧内のスペースを追加または削除します
#「new（foo）BAR」のように。
sp_inside_newop_paren = ignore	#ignore / add / remove / force

#新しい演算子の開き括弧の後にスペースを追加または削除します。
#「new（foo）BAR」のように。
#
#sp_inside_newop_parenをオーバーライドします。
sp_inside_newop_paren_open = ignore	#ignore / add / remove / force

#新しい演算子の閉じ括弧の前にスペースを追加または削除します。
#「new（foo）BAR」のように。
#
#sp_inside_newop_parenをオーバーライドします。
sp_inside_newop_paren_close = ignore	#ignore / add / remove / force

#末尾または埋め込みコメントの前にスペースを追加または削除します。
sp_before_tr_emb_cmt = ignore	#ignore / add / remove / force

#末尾または埋め込みコメントの前のスペースの数。
sp_num_before_tr_emb_cmt = 0	#符号なしの数値

#（Java）注釈と開き括弧の間にスペースを追加または削除します。
sp_annotation_paren = ignore	#ignore / add / remove / force

#trueの場合、vbraceトークンは前のトークンにドロップされ、スキップされます。
sp_skip_vbrace_tokens = false	#true / false

#「noexcept」の後にスペースを追加または削除します。
sp_after_noexcept = ignore	#ignore / add / remove / force

#trueの場合、<TAB>が	#defineの後に挿入されます。
force_tab_after_define = false	#true / false

#
#インデントオプション
#

#レベルごとにインデントする列の数。通常、2、3、4、または8。
#
#デフォルト：8
indent_columns = 4	#符号なしの数値

#継続インデント。ゼロ以外の場合、これは '（'および
# '='継続インデント。負の値はOKです。負の値は絶対です
#および '（'レベルごとに増加しません。
#
#FreeBSDの場合、これは4に設定されます。
indent_continue = 0	#数値

#継続インデント。クラスヘッダー行のみ。ゼロ以外の場合、これ
#「クラス」継続インデントのインデントをオーバーライドします。
indent_continue_class_head = 0	#符号なしの数値

#空の行（つまり、前にスペースのみを含む行）をインデントするかどうか
#改行文字）。
indent_single_newlines = false	#true / false

#それらがtrueの場合、func _ * _paramの継続インデント。ゼロ以外の場合、これ
#インデントをオーバーライドします。
indent_param = 0	#符号なしの数値

#コードをインデントするときにタブを使用する方法。
#
#0：スペースのみ
#1：中括弧レベルにタブでインデントし、スペースに揃えます（デフォルト）
#2：タブストップ上にないときはスペースを使用して、タブをインデントして整列します
#
#デフォルト：1
indent_with_tabs = 2	#符号なしの数値

#中括弧レベルにないコメントをインデントするかどうか
#タブストップ。indent_with_tabs = 2が必要です。falseの場合、スペースを使用します。
indent_cmt_with_tabs = true	#true / false

#「\」で区切られた文字列をインデントして整列させるかどうか。
indent_align_string = false	#true / false

#複数行のXML文字列をインデントするスペースの数。
#indent_align_string = trueが必要です。
indent_xml_string = 0	#符号なしの数値

#レベルから「{」をインデントするスペース。
indent_brace = 0	#符号なしの数値

#中括弧が体の高さにインデントされているかどうか。
indent_braces = false	#true / false

#indent_braces = trueの場合、インデント関数の中括弧を無効にするかどうか。
indent_braces_no_func = false	#true / false

#indent_braces = trueの場合、クラス中括弧のインデントを無効にするかどうか。
indent_braces_no_class = false	#true / false

#indent_braces = trueの場合、構造体中括弧のインデントを無効にするかどうか。
indent_braces_no_struct = false	#true / false

#中括弧の親のサイズに基づいてインデントするかどうか、
#ie'if '竊 3スペース、' for '竊 4スペースなど。
indent_brace_parent = false	#true / false

#中括弧ではなく、中括弧に基づいてインデントするかどうか
# 宿'。
indent_paren_open_brace = true	#!!!! 真/偽

#（C	#）C	#デリゲートのブレースを別のレベルでインデントするかどうか。
indent_cs_delegate_brace = false	#true / false

#（C	#）C	#デリゲートをインデントするかどうか（中括弧なしでデリゲートを処理するため）
# 別のレベル。
indent_cs_delegate_body = false	#true / false

#「名前空間」の本体をインデントするかどうか。
indent_namespace = false	#true / false

#ネストされた名前空間ではなく、最初の名前空間のみをインデントするかどうか。
#indent_namespace = trueが必要です。
indent_namespace_single_indent = false	#true / false

#名前空間ブロックをインデントするスペースの数。
indent_namespace_level = 0	#符号なしの数値

#名前空間の本体がこの数より長い場合、
#インデント。indent_namespace = trueが必要です。0は制限がないことを意味します。
indent_namespace_limit = 0	#符号なしの数値

# 'extern "C"'本体がインデントされているかどうか。
indent_extern = false	#true / false

#「クラス」本体がインデントされているかどうか。
indent_class = false	#true / false

#主要な基本クラスのコロンの後にインデントするかどうか。
indent_class_colon = false	#true / false

#後のものではなく、クラスのコロンに基づいてインデントするかどうか
#コロン。indent_class_colon = trueが必要です。
indent_class_on_colon = false	#true / false

#先頭のクラス初期化コロンの後にインデントするかどうか。
indent_constr_colon = false	#true / false

#メンバー初期化子の「：」からの仮想インデント。
#
#デフォルト：2
indent_ctor_init_leading = 2	#符号なしの数値

#コンストラクタ初期化子リストの追加のインデント。
#負の値は、最初の列までインデントを減らします。
indent_ctor_init = 0	#数値

#「else」の下の新しいブロックとして「else」に続く「if」をインデントするかどうか。
#falseの場合、インデントの目的で「else \ nif」は「elseif」として扱われます。
indent_else_if = false	#true / false

#中括弧の後に変数宣言をインデントする量。
#
#<0：相対
#竕・0：絶対
indent_var_def_blk = 0	#番号

#整列する代わりに、継続する変数宣言をインデントするかどうか。
indent_var_def_cont = false	#true / false

#代わりに継続シフト式（ '<<'および '>>'）をインデントするかどうか
#整列。これを有効にする場合は、align_left_shift = falseを設定します。
indent_shift = false	#true / false

#関数定義のインデントを強制的に列1から開始するかどうか。
indent_func_def_force_col1 = false	#true / false

#継続する関数呼び出しパラメーターを1つのインデントレベルでインデントするかどうか、
#開き括弧の下にパラメーターを揃えるのではなく。
indent_func_call_param = false	#true / false

#indent_func_call_paramと同じですが、関数定義用です。
indent_func_def_param = false	#true / false

#indent_func_call_paramと同じですが、関数プロトタイプ用です。
indent_func_proto_param = false	#true / false

#indent_func_call_paramと同じですが、クラス宣言用です。
indent_func_class_param = false	#true / false

#indent_func_call_paramと同じですが、クラス変数コンストラクター用です。
indent_func_ctor_var_param = false	#true / false

#indent_func_call_paramと同じですが、テンプレートパラメータリスト用です。
indent_template_param = false	#true / false

#indent_func_xxx_paramオプションのインデントを2倍にします。
#オプションindent_columnsとindent_paramの両方の値を使用します。
indent_func_param_double = false	#true / false

#関数のスタンドアロンの「const」修飾子のインデント列
#プロトタイプ。
indent_func_const = 0	#符号なしの番号

#関数のスタンドアロンの「throw」修飾子のインデント列
#プロトタイプ。
indent_func_throw = 0	#符号なしの数値

#継続する「->」または「。」をインデントするスペースの数。
#通常は0、1、またはindent_columnsに設定されます。
indent_member = 0	#符号なしの数値

#行が「。」で壊れているかどうか または「->」は単一のインデントでインデントする必要があります。
#これがtrueに設定されている場合、indent_memberオプションは有効になりません。
indent_member_single = false	#true / false

#コードの前の行に1行（ ' //'）コメントをインデントするスペース。
indent_sing_line_comments = 0	#符号なしの数値

#コードに関連して末尾の1行（ ' //'）コメントをインデントするかどうか
#同じ絶対列を維持しようとする代わりに。
indent_relative_single_line_comments = false	#true / false

#「switch」から「case」をインデントするスペース。通常は0またはindent_columnsです。
indent_switch_case = 0	#符号なしの数値

#switchステートメント内でプリプロセッサステートメントをインデントするかどうか。
#
#デフォルト：true
indent_switch_pp = true	#true / false

#他の行に影響を与えずに、「case」行をシフトするためのスペース。
#通常は0。
indent_case_shift = 2	#符号なしの数値

#「case」から「{」をインデントするスペース。デフォルトでは、中括弧は下に表示されます
#「c」の場合。通常、0またはindent_columnsに設定されます。負の値はOKです。
indent_case_brace = 4	#数値

#最初の列にあるコメントをインデントするかどうか。
indent_col1_comment = false	#true / false

#gotoラベルをインデントする方法。
#
# >0：絶対列（1は左端の列）
# ?0：中括弧のインデントから減算
#
#デフォルト：1
indent_label = 1	#番号

#indent_labelと同じですが、後に続くアクセス指定子用です。
#コロン。
#
#デフォルト：1
indent_access_spec = 1	#番号

#アクセス指定子の後にコードを1レベルインデントするかどうか。
#trueの場合、このオプションは「indent_access_spec = 0」を強制します。
indent_access_spec_body = false	#true / false

#開き括弧の後に改行が続く場合、次をインデントするかどうか
#行は、開いた括弧の後に並ぶようにします（非推奨）。
indent_paren_nl = false	#true / false

#改行の後に閉じ括弧をインデントする方法。
#
#0：ボディレベルにインデントする（デフォルト）
#1：開き括弧の下に揃える
#2：ブレースレベルにインデントする
indent_paren_close = 0	#符号なしの数値

#関数定義の開き括弧をインデントするかどうか、
#括弧が独自の行にある場合。
indent_paren_after_func_def = false	#true / false

#関数宣言の開き括弧をインデントするかどうか、
#括弧が独自の行にある場合。
indent_paren_after_func_decl = false	#true / false

#関数呼び出しの開き括弧をインデントするかどうか、
#括弧が独自の行にある場合。
indent_paren_after_func_call = false	#true / false

#括弧内にコンマをインデントするかどうか。
#trueの場合、開き括弧の下に配置されます。
indent_comma_paren = false	#true / false

#括弧内にブール演算子をインデントするかどうか。
#trueの場合、開き括弧の下に配置されます。
indent_bool_paren = false	#true / false

#括弧内にセミコロンをインデントするかどうか。
#trueの場合、括弧内のオープンの下に整列します。
indent_semicolon_for_paren = false	#true / false

#最初の式を次の式に揃えるかどうか
#indent_bool_paren = trueの場合。
indent_first_bool_expr = false	#true / false

#最初の式を次の式に揃えるかどうか
#indent_semicolon_for_paren = trueの場合。
indent_first_for_expr = false	#true / false

#開いた正方形の後に改行が続く場合、次の行をインデントするかどうか
#開いた正方形の後に並ぶようにします（非推奨）。
indent_square_nl = false	#true / false

#（ESQL / C）「EXECSQL」本体の相対インデントを保持するかどうか。
indent_preserve_sql = false	#true / false

#継続するステートメントを「=」に揃えるかどうか。falseの場合、または '='が
#その後に改行が続く場合、次の行は1つのタブをインデントします。
#
#デフォルト：true
indent_align_assign = true	#true / false

#継続するステートメントを '（'に揃えるかどうか。falseまたは '（'がそうでない場合
#その後に改行が続く場合、次の行のインデントは1つのタブです。
#
#デフォルト：true
indent_align_paren = true	#true / false

#（OC）Objective-Cブロックを通常ではなく中括弧レベルでインデントするかどうか
#ルール。
indent_oc_block = false	#true / false

#（OC）パラメータに関連するメッセージ内のObjective-Cブロックのインデント
# 名前。
#
#= 0：indent_oc_blockルールを使用する
#> 0：指定された数のスペースを使用してインデントします
indent_oc_block_msg = 0	#符号なしの数値

#（OC）後続のパラメーターの最小インデント
indent_oc_msg_colon = 0	#符号なしの数値

#（OC）最初のコロンとの位置合わせ（およびスペースの削除）を優先するかどうか
#必要に応じて行から）。
#
#デフォルト：true
indent_oc_msg_prioritize_first_colon = true	#true / false

#（OC）Xcodeがデフォルトで行う方法でブロックをインデントするかどうか
#（パラメータが独自の行にある場合はキーワードから、それ以外の場合は
#前のインデントレベル）。indent_oc_block_msg = trueが必要です。
indent_oc_block_msg_xcode_style = false	#true / false

#（OC）中括弧がある場所からブロックをインデントするかどうか、
#メッセージキーワード。indent_oc_block_msg = trueが必要です。
indent_oc_block_msg_from_keyword = false	#true / false

#（OC）メッセージに関連して、中括弧がある場所からブロックをインデントするかどうか
#コロン。indent_oc_block_msg = trueが必要です。
indent_oc_block_msg_from_colon = false	#true / false

#（OC）ブロックキャレットがある場所からブロックをインデントするかどうか。
#indent_oc_block_msg = trueが必要です。
indent_oc_block_msg_from_caret = false	#true / false

#（OC）ブレースキャレットがある場所からブロックをインデントするかどうか。
#indent_oc_block_msg = trueが必要です。
indent_oc_block_msg_from_brace = false	#true / false

#仮想ブレースを開いて改行した後にインデントする場合は、さらにスペースを追加します
#この最小インデントに到達します。
indent_min_vbrace_open = 0	#符号なしの数値

#次のタブストップに到達するために通常のインデントの後にスペースを追加するかどうか
#仮想ブレースを開いて改行した後に識別する場合。
indent_vbrace_open_on_tabstop = false	#true / false

#中括弧とそれに続く別のトークン（改行ではない）の後にインデントする方法。
#true：トークンに一致するように含まれるすべての行をインデントします
#false：中括弧に一致するように含まれるすべての行をインデントします
#
#デフォルト：true
indent_token_after_brace = true	#true / false

#C ++ 11ラムダの本体をインデントするかどうか。
indent_cpp_lambda_body = false	#true / false

#（C	#）中括弧が使用されていない場合に「using」ブロックをインデントするかどうか。
#
#デフォルト：true
indent_using_block = true	#true / false

#三項演算子の継続をインデントする方法。
#
#0：オフ（デフォルト）
#1：?if_false`が継続である場合、?if_false`の下にインデントします
#2： `：`が継続の場合は、 `？`の下にインデントします。
indent_ternary_operator = 0	#符号なしの数値

#trueの場合、 `return new`シーケンスの後のチャンクのインデントは、returnインデント列に設定されます。
indent_off_after_return_new = false	#true / false

#trueの場合、戻り後のトークンは通常の単一インデントでインデントされます。デフォルト（false）では、インデントはリターントークンの後にあります。
indent_single_after_return = false	#true / false

# 'asm'ブロックのインデントと配置を無視するかどうか（つまり、
#独自のインデントがあります）。
indent_ignore_asm_block = false	#true / false

#
#改行の追加と削除のオプション
#

# '{'と '}'の間の空のブロックを折りたたむかどうか。
nl_collapse_empty_body = false	#true / false

# 'foo_t f = {1、2};'のように、1行のブレース付き割り当てを分割しないでください。
nl_assign_leave_one_liners = false	#true / false

# 'class xx {}'本文内で1行のブレースステートメントを分割しないでください。
nl_class_leave_one_liners = false	#true / false

# 'enum foo {BAR = 15};'のように、1行の列挙型を分割しないでください。
nl_enum_leave_one_liners = false	#true / false

#1行のget関数またはset関数を分割しないでください。
nl_getset_leave_one_liners = false	#true / false

#（C	#）1行のプロパティgetまたはset関数を分割しないでください。
nl_cs_property_leave_one_liners = false	#true / false

# 'int foo（）{return 0;のように、1行の関数定義を分割しないでください。} '。
nl_func_leave_one_liners = false	#true / false

# '[]（）{return 0;のように、1行のC ++ 11ラムダを分割しないでください。} '。
nl_cpp_lambda_leave_one_liners = false	#true / false

# 'if（...）b ++;'のように、1行のif / elseステートメントを分割しないでください。
nl_if_leave_one_liners = false	#true / false

# 'while（...）b ++;'のように、1行のwhileステートメントを分割しないでください。
nl_while_leave_one_liners = false	#true / false

# 'for（...）b ++;'のように、ステートメントの1行を分割しないでください。
nl_for_leave_one_liners = false	#true / false

#（OC）1行のObjective-Cメッセージを分割しないでください。
nl_oc_msg_leave_one_liner = false	#true / false

#（OC）メソッド宣言と '{'の間に改行を追加または削除します。
nl_oc_mdef_brace = ignore	#ignore / add / remove / force

#（OC）Objective-Cブロック署名と「{」の間に改行を追加または削除します。
nl_oc_block_brace = ignore	#ignore / add / remove / force

#（OC）「@ interface」と「{」の間に改行を追加または削除します。
nl_oc_interface_brace = ignore	#ignore / add / remove / force

#（OC）「@ implementation」と「{」の間に改行を追加または削除します。
nl_oc_implementation_brace = ignore	#ignore / add / remove / force

#ファイルの先頭で改行を追加または削除します。
nl_start_of_file = ignore	#ignore / add / remove / force

#ファイルの先頭にある改行の最小数（次の場合にのみ使用）
#nl_start_of_fileは「add」または「force」です）。
nl_start_of_file_min = 0	#符号なしの数値

#ファイルの最後に改行を追加または削除します。
nl_end_of_file = force	#ignore / add / remove / force

#ファイルの最後にある改行の最小数（次の場合にのみ使用）
#nl_end_of_fileは「add」または「force」です）。
nl_end_of_file_min = 1	#符号なしの数値

#「=」と「{」の間に改行を追加または削除します。
nl_assign_brace = ignore	#ignore / add / remove / force

#（D） '='と '['の間に改行を追加または削除します。
nl_assign_square = ignore	#ignore / add / remove / force

#「[]」と「{」の間に改行を追加または削除します。
nl_tsquare_brace = ignore	#ignore / add / remove / force

#（D） '= ['の後に改行を追加または削除します。以前の改行にも影響します
# ']'。
nl_after_square_assign = ignore	#ignore / add / remove / force

#上部の変数定義のブロックの後の空白行の数
#関数本体の。
#
#0 =変更なし（デフォルト）。
nl_func_var_def_blk = 0	#符号なしの数値

#typedefのブロックの前の改行の数。nl_after_access_specの場合
#がゼロ以外の場合、そのオプションが優先されます。
#
#0 =変更なし（デフォルト）。
nl_typedef_blk_start = 0	#符号なしの数値

#typedefのブロックの後の改行の数。
#
#0 =変更なし（デフォルト）。
nl_typedef_blk_end = 0	#符号なしの数値

#typedefのブロック内の連続する改行の最大数。
#
#0 =変更なし（デフォルト）。
nl_typedef_blk_in = 0	#符号なしの数値

#変数定義のブロックの前にある改行の数が一番上にない
#関数本体の。nl_after_access_specがゼロ以外の場合、そのオプションは
#優先順位。
#
#0 =変更なし（デフォルト）。
nl_var_def_blk_start = 0	#符号なしの数値

#変数定義のブロックの後の改行の数が一番上にない
#関数本体の。
#
#0 =変更なし（デフォルト）。
nl_var_def_blk_end = 0	#符号なしの数値

#変数のブロック内の連続する改行の最大数
#定義。
#
#0 =変更なし（デフォルト）。
nl_var_def_blk_in = 0	#符号なしの数値

#関数呼び出しの「）」と「{」の間に改行を追加または削除します。
# 'list_for_each（item、＆list）{}'。
nl_fcall_brace = ignore	#ignore / add / remove / force

#「enum」と「{」の間に改行を追加または削除します。
nl_enum_brace = ignore	#ignore / add / remove / force

#「enum」と「class」の間に改行を追加または削除します。
nl_enum_class = ignore	#ignore / add / remove / force

#「列挙型クラス」と識別子の間に改行を追加または削除します。
nl_enum_class_identifier = ignore	#ignore / add / remove / force

#「列挙型クラス」タイプと「：」の間に改行を追加または削除します。
nl_enum_identifier_colon = ignore	#ignore / add / remove / force

#「列挙型クラス識別子：」とタイプの間に改行を追加または削除します。
nl_enum_colon_type = ignore	#ignore / add / remove / force

# 'structと' {'の間に改行を追加または削除します。
nl_struct_brace = ignore	#ignore / add / remove / force

#「union」と「{」の間に改行を追加または削除します。
nl_union_brace = ignore	#ignore / add / remove / force

#「if」と「{」の間に改行を追加または削除します。
nl_if_brace = ignore	#ignore / add / remove / force

#「}」と「else」の間に改行を追加または削除します。
nl_brace_else = ignore	#ignore / add / remove / force

#「elseif」と「{」の間に改行を追加または削除します。無視するように設定されている場合、
#代わりにnl_if_braceが使用されます。
nl_elseif_brace = ignore	#ignore / add / remove / force

#「else」と「{」の間に改行を追加または削除します。
nl_else_brace = ignore	#ignore / add / remove / force

#「else」と「if」の間に改行を追加または削除します。
nl_else_if = ignore	#ignore / add / remove / force

# 'if' / 'elseif'の前に改行を追加または削除します。
nl_before_if_closeing_paren = ignore	#ignore / add / remove / force

#「}」と「finally」の間に改行を追加または削除します。
nl_brace_finally = ignore	#ignore / add / remove / force

#「finally」と「{」の間に改行を追加または削除します。
nl_finally_brace = ignore	#ignore / add / remove / force

#「try」と「{」の間に改行を追加または削除します。
nl_try_brace = ignore	#ignore / add / remove / force

#get / setと '{'の間に改行を追加または削除します。
nl_getset_brace = ignore	#ignore / add / remove / force

#「for」と「{」の間に改行を追加または削除します。
nl_for_brace = ignore	#ignore / add / remove / force

#「catch」ステートメントの「{」の前に改行を追加または削除します。
# 'catch（decl）<ここ> {'。
nl_catch_brace = ignore	#ignore / add / remove / force

#（OC）「@ catch」ステートメントの「{」の前に改行を追加または削除します。
# '@ catch（decl）<ここ> {'。無視するように設定されている場合、nl_catch_braceが使用されます。
nl_oc_catch_brace = ignore	#ignore / add / remove / force

#「}」と「catch」の間に改行を追加または削除します。
nl_brace_catch = ignore	#ignore / add / remove / force

#（OC）「}」と「@catch」の間に改行を追加または削除します。無視するように設定されている場合、
#nl_brace_catchが使用されます。
nl_oc_brace_catch = ignore	#ignore / add / remove / force

# '}'と ']'の間に改行を追加または削除します。
nl_brace_square = ignore	#ignore / add / remove / force

#関数呼び出しで「}」と「）」の間に改行を追加または削除します。
nl_brace_fparen = ignore	#ignore / add / remove / force

#「while」と「{」の間に改行を追加または削除します。
nl_while_brace = ignore	#ignore / add / remove / force

#（D） 'scope（x）'と '{'の間に改行を追加または削除します。
nl_scope_brace = ignore	#ignore / add / remove / force

#（D）「unittest」と「{」の間に改行を追加または削除します。
nl_unittest_brace = ignore	#ignore / add / remove / force

#（D）「バージョン（x）」と「{」の間に改行を追加または削除します。
nl_version_brace = ignore	#ignore / add / remove / force

#（C	#） 'using'と '{'の間に改行を追加または削除します。
nl_using_brace = ignore	#ignore / add / remove / force

#2つの中括弧または中括弧の間に改行を追加または削除します。一般的な理由による
#改行/中括弧の処理、REMOVEが機能しない場合があります。
nl_brace_brace = ignore	#ignore / add / remove / force

#「do」と「{」の間に改行を追加または削除します。
nl_do_brace = ignore	#ignore / add / remove / force

#「do」ステートメントの「}」と「while」の間に改行を追加または削除します。
nl_brace_while = ignore	#ignore / add / remove / force

#「switch」と「{」の間に改行を追加または削除します。
nl_switch_brace = ignore	#ignore / add / remove / force

#「同期」と「{」の間に改行を追加または削除します。
nl_synchronized_brace = ignore	#ignore / add / remove / force

#「）」がとは異なる行にある場合は、「）」と「{」の間に改行を追加します
#if / for / etc。
#
#nl_for_brace、nl_if_brace、nl_switch_brace、nl_while_switch、およびをオーバーライドします
#nl_catch_brace。
nl_multi_line_cond = false	#true / false

#複数行定義のマクロ名の後に、定義で改行を強制します。
nl_multi_line_define = false	#true / false

#「case」の前に改行を追加し、「case」の前に空白行を追加するかどうか
# ';'に続くステートメント または '}'。
nl_before_case = false	#true / false

# 'case'ステートメントの後に改行を追加するかどうか。
nl_after_case = false	#true / false

#ケース '：'と '{'の間に改行を追加または削除します。
#
#nl_after_caseをオーバーライドします。
nl_case_colon_brace = ignore	#ignore / add / remove / force

#「）」と「throw」の間に改行を追加または削除します。
nl_before_throw = ignore	#ignore / add / remove / force

#「名前空間」と「{」の間に改行を追加または削除します。
nl_namespace_brace = ignore	#ignore / add / remove / force

# 'template <>'とそれに続くものの間に改行を追加または削除します。
nl_template_class = ignore	#ignore / add / remove / force

#「class」と「{」の間に改行を追加または削除します。
nl_class_brace = ignore	#ignore / add / remove / force

#それぞれの前または後に（pos_class_commaに応じて）改行を追加または削除します
#基本クラスリストの '、'。
nl_class_init_args = ignore	#ignore / add / remove / force

#コンストラクターメンバーの各 '、'の後に改行を追加または削除します
#初期化。nl_constr_colon、pos_constr_colon、および
#pos_constr_comma。
nl_constr_init_args = ignore	#ignore / add / remove / force

#最初の要素の前、コンマの後、最後の後に改行を追加または削除します
#要素、「列挙型」。
nl_enum_own_lines = ignore	#ignore / add / remove / force

#関数の戻り値の型と関数名の間に改行を追加または削除します
#定義。
nl_func_type_name = ignore	#ignore / add / remove / force

#クラス内の戻り値の型と関数名の間に改行を追加または削除します
#定義。無視するように設定されている場合、nl_func_type_nameまたはnl_func_proto_type_name
#代わりに が使用されます。
nl_func_type_name_class = ignore	#ignore / add / remove / force

#クラス指定と ': :'の間に改行を追加または削除します
#in'void A : : f（）{} '。個別のメンバー実装にのみ表示されます（
#インライン実装では表示されません）。
nl_func_class_scope = ignore	#ignore / add / remove / force

#関数スコープと名前の間に改行を追加または削除します。
# 'void A : : <here> f（）{}'。
nl_func_scope_name = ignore	#ignore / add / remove / force

#プロトタイプの戻り値の型と関数名の間に改行を追加または削除します。
nl_func_proto_type_name = ignore	#ignore / add / remove / force

#関数名と開口部の間に改行を追加または削除します '（'
#宣言。
nl_func_paren = ignore	#ignore / add / remove / force

#パラメーターのない関数のnl_func_parenをオーバーライドします。
nl_func_paren_empty = ignore	#ignore / add / remove / force

#関数名と開口部の間に改行を追加または削除します '（'
#定義。
nl_func_def_paren = ignore	#ignore / add / remove / force

#パラメーターのない関数のnl_func_def_parenをオーバーライドします。
nl_func_def_paren_empty = ignore	#ignore / add / remove / force

#関数名と開口部の間に改行を追加または削除します '（'
#電話します。
nl_func_call_paren = ignore	#ignore / add / remove / force

#パラメーターのない関数のnl_func_call_parenをオーバーライドします。
nl_func_call_paren_empty = ignore	#ignore / add / remove / force

#関数宣言の '（'の後に改行を追加または削除します。
nl_func_decl_start = ignore	#ignore / add / remove / force

#関数定義の '（'の後に改行を追加または削除します。
nl_func_def_start = ignore	#ignore / add / remove / force

#パラメータが1つしかない場合、nl_func_decl_startをオーバーライドします。
nl_func_decl_start_single = ignore	#ignore / add / remove / force

#パラメータが1つしかない場合、nl_func_def_startをオーバーライドします。
nl_func_def_start_single = ignore	#ignore / add / remove / force

#関数宣言の '（'の後に改行を追加するかどうかif '（' and '）'
#は別の行にあります。falseの場合、代わりにnl_func_decl_startが使用されます。
nl_func_decl_start_multi_line = false	#true / false

#関数定義の '（'の後に改行を追加するかどうかif '（' and '）'
#は別の行にあります。falseの場合、代わりにnl_func_def_startが使用されます。
nl_func_def_start_multi_line = false	#true / false

#関数宣言の各 '、'の後に改行を追加または削除します。
nl_func_decl_args = ignore	#ignore / add / remove / force

#関数定義の各 '、'の後に改行を追加または削除します。
nl_func_def_args = ignore	#ignore / add / remove / force

#関数宣言の各 '、'の後に改行を追加するかどうかif '（'
#と '）'は別の行にあります。falseの場合、代わりにnl_func_decl_argsが使用されます。
nl_func_decl_args_multi_line = false	#true / false

#関数定義の各 '、'の後に改行を追加するかどうかif '（'
#と '）'は別の行にあります。falseの場合、代わりにnl_func_def_argsが使用されます。
nl_func_def_args_multi_line = false	#true / false

#関数宣言の「）」の前に改行を追加または削除します。
nl_func_decl_end = ignore	#ignore / add / remove / force

#関数定義の「）」の前に改行を追加または削除します。
nl_func_def_end = ignore	#ignore / add / remove / force

#パラメータが1つしかない場合、nl_func_decl_endをオーバーライドします。
nl_func_decl_end_single = ignore	#ignore / add / remove / force

#パラメータが1つしかない場合、nl_func_def_endをオーバーライドします。
nl_func_def_end_single = ignore	#ignore / add / remove / force

#関数宣言の '）'の前に改行を追加するかどうかif '（' and '）'
#は別の行にあります。falseの場合、代わりにnl_func_decl_endが使用されます。
nl_func_decl_end_multi_line = false	#true / false

#関数定義の '）'の前に改行を追加するかどうかif '（' and '）'
#は別の行にあります。falseの場合、代わりにnl_func_def_endが使用されます。
nl_func_def_end_multi_line = false	#true / false

#関数宣言の「（）」の間に改行を追加または削除します。
nl_func_decl_empty = ignore	#ignore / add / remove / force

#関数定義の「（）」の間に改行を追加または削除します。
nl_func_def_empty = ignore	#ignore / add / remove / force

#関数呼び出しの「（）」の間に改行を追加または削除します。
nl_func_call_empty = ignore	#ignore / add / remove / force

# '（'および '）'が含まれている場合、関数呼び出しで '（'の後に改行を追加するかどうか
#異なる行。
nl_func_call_start_multi_line = false	#true / false

#関数呼び出しの各 '、'の後に改行を追加するかどうかif '（' and '）'
#は別の行にあります。
nl_func_call_args_multi_line = false	#true / false

# '（'および '）'が含まれている場合、関数呼び出しで '）'の前に改行を追加するかどうか
#異なる行。
nl_func_call_end_multi_line = false	#true / false

#（OC）各Objective-Cメッセージパラメータを別々の行に配置するかどうか。
#nl_oc_msg_leave_one_linerを参照してください。
nl_oc_msg_args = false	#true / false

#関数シグネチャと '{'の間に改行を追加または削除します。
nl_fdef_brace = ignore	#ignore / add / remove / force

#C ++ 11ラムダ署名と「{」の間に改行を追加または削除します。
nl_cpp_ldef_brace = ignore	#ignore / add / remove / force

# 'return'とreturn式の間に改行を追加または削除します。
nl_return_expr = ignore	#ignore / add / remove / force

# 'for'ステートメントを除いて、セミコロンの後に改行を追加するかどうか。
nl_after_semicolon = false	#true / false

#（Java）二重中括弧の「）」と「{」の間に改行を追加または削除します
#初期化子。
nl_paren_dbrace_open = ignore	#ignore / add / remove / force

#名前のない一時的なタイプの後に改行を追加するかどうか
#direct-list-initialization。
nl_type_brace_init_lst = ignore	#ignore / add / remove / force

#名前のない一時的な中括弧の後に改行を追加するかどうか
#direct-list-initialization。
nl_type_brace_init_lst_open = ignore	#ignore / add / remove / force

#名前のない一時的な中括弧の前に改行を追加するかどうか
#direct-list-initialization。
nl_type_brace_init_lst_close = ignore	#ignore / add / remove / force

# '{'の後に改行を追加するかどうか。これにより、前に改行も追加されます
#一致する '}'。
nl_after_brace_open = false	#true / false

#開いた中括弧と末尾の単一行の間に改行を追加するかどうか
#コメント。nl_after_brace_open = trueが必要です。
nl_after_brace_open_cmt = false	#true / false

#空でない本体で仮想ブレースを開いた後に改行を追加するかどうか。
#これらは、中括弧のないif / while / do / forステートメント本体で発生します。
nl_after_vbrace_open = false	#true / false

#空の本体で仮想ブレースを開いた後に改行を追加するかどうか。
#これらは、中括弧のないif / while / do / forステートメント本体で発生します。
nl_after_vbrace_open_empty = false	#true / false

# '}'の後に改行を追加するかどうか。が続く場合は適用されません
#必要な ';'。
nl_after_brace_close = false	#true / false

#仮想ブレースを閉じた後に改行を追加するかどうか、
# 'のようにif（foo）a ++; <ここ> return; '。
nl_after_vbrace_close = false	#true / false

#閉じ中括弧と識別子の間に改行を追加または削除します。
# 'struct {int a;} <ここ> b; '。列挙、ユニオン、およびに影響します
#構造。無視するように設定されている場合は、nl_after_brace_closeを使用します。
nl_brace_struct_var = ignore	#ignore / add / remove / force

# '	#define'マクロの改行を変更するかどうか。
nl_define_macro = false	#true / false

#連続する括弧の間に改行を変更するかどうか。番号
#行の閉じ括弧の数は、それぞれの開き括弧によって異なります。
#行。
nl_squeeze_paren_close = false	#true / false

#「	#ifxx」と「	#elxx」の後、または「	#elxx」と「	#elxx」の前の空白を削除するかどうか
# '	#endif'。トップレベルの	#ifdefには影響しません。
nl_squeeze_ifdef = false	#true / false

#nl_squeeze_ifdefオプションがトップレベルの	#ifdefにも影響するようにします。
nl_squeeze_ifdef_top_level = false	#true / false

#「if」の前の空白行を追加または削除します。
nl_before_if = ignore	#ignore / add / remove / force

# 'if'ステートメントの後に空白行を追加または削除します。追加/強制は、
#次のトークンは中括弧ではありません。
nl_after_if = ignore	#ignore / add / remove / force

#「for」の前の空白行を追加または削除します。
nl_before_for = ignore	#ignore / add / remove / force

# 'for'ステートメントの後に空白行を追加または削除します。
nl_after_for = ignore	#ignore / add / remove / force

#「while」の前の空白行を追加または削除します。
nl_before_while = ignore	#ignore / add / remove / force

#「while」ステートメントの後に空白行を追加または削除します。
nl_after_while = ignore	#ignore / add / remove / force

#「switch」の前に空白行を追加または削除します。
nl_before_switch = ignore	#ignore / add / remove / force

# 'switch'ステートメントの後に空白行を追加または削除します。
nl_after_switch = ignore	#ignore / add / remove / force

#「同期」の前に空白行を追加または削除します。
nl_before_synchronized = ignore	#ignore / add / remove / force

#「同期」ステートメントの後に空白行を追加または削除します。
nl_after_synchronized = ignore	#ignore / add / remove / force

#「do」の前に空白行を追加または削除します。
nl_before_do = ignore	#ignore / add / remove / force

#「do / while」ステートメントの後に空白行を追加または削除します。
nl_after_do = ignore	#ignore / add / remove / force

#「struct」/「union」/「enum」のコメント付きエントリをダブルスペースにするかどうか。
nl_ds_struct_enum_cmt = false	#true / false

# 'struct' / 'union' / 'enum'の '}'の前に改行を強制するかどうか。
#（eat_blanks_before_close_braceよりも優先度が低い。）
nl_ds_struct_enum_close_brace = false	#true / false

#クラスの前後（pos_class_colonに応じて）に改行を追加または削除します
#コロン、 'class Foo <here>：<or here> publicBar'のように。
nl_class_colon = ignore	#ignore / add / remove / force

#クラスコンストラクタのコロンの周りに改行を追加または削除します。正確な位置
#nl_constr_init_args、pos_constr_colon、pos_constr_commaに依存します。
nl_constr_colon = ignore	#ignore / add / remove / force

# 'namespace foo \ n {decl;のように、2行の名前空間を折りたたむかどうか} '
#1行に。trueの場合、他のブレース改行ルールが回転しないようにします
#そのようなコードを4行に。
nl_namespace_two_to_one_liner = false	#true / false

#ブレースなしの単純なifステートメントで改行を削除するかどうか
# 'if（b）\ n i ++;'のように、ワンライナーに 竊 'if（b）i ++; '。
nl_create_if_one_liner = false	#true / false

#ステートメントのブレースなしの単純な改行を削除するかどうか
# 'for（...）\ n stmt;'のように、ワンライナーに 竊  '（...）stmt;'。
nl_create_for_one_liner = false	#true / false

#ブレースなしの単純なwhileステートメントで改行を削除するかどうか
# 'while（expr）\ n stmt;'のように、それらをワンライナーに変換します。竊 'while（expr）stmt; '。
nl_create_while_one_liner = false	#true / false

#本体（中括弧は数えない）の関数定義を折りたたむかどうか
#は1行だけなので、定義全体（プロトタイプ、中括弧、本文）は次のようになります。
#1行。
nl_create_func_def_one_liner = false	#true / false

#1行の単純な括弧なしのifステートメントを2行に分割するかどうか
# 'if（b）<here> i ++;'のように、改行を追加します。
nl_split_if_one_liner = false	#true / false

#ステートメントの1行の単純な括弧なしを2行に分割するかどうか
# 'for（...）<here> stmt;'のように、改行を追加します。
nl_split_for_one_liner = false	#true / false

#1行の単純な括弧なしのwhileステートメントを2行に分割するかどうか
# 'while（expr）<here> stmt;'のように、改行を追加します。
nl_split_while_one_liner = false	#true / false

#
#空白行オプション
#

#連続する改行の最大数（3 = 2つの空白行）。
nl_max = 0	#符号なし数値

#関数内の連続する改行の最大数。
nl_max_blank_in_func = 0	#符号なしの数値

#関数プロトタイプの前の改行の数。
nl_before_func_body_proto = 0	#符号なしの数値

#複数行の関数定義の前の改行の数。
nl_before_func_body_def = 0	#符号なしの数値

#クラスコンストラクタ/デストラクタプロトタイプの前の改行の数。
nl_before_func_class_proto = 0	#符号なしの数値

#クラスコンストラクタ/デストラクタ定義の前の改行の数。
nl_before_func_class_def = 0	#符号なしの数値

#関数プロトタイプ後の改行の数。
nl_after_func_proto = 0	#符号なしの数値

#関数プロトタイプの後の改行の数（その後にない場合）
#別の関数プロトタイプ。
nl_after_func_proto_group = 0	#符号なしの数値

#クラスコンストラクタ/デストラクタプロトタイプ後の改行の数。
nl_after_func_class_proto = 0	#符号なしの数値

#クラスコンストラクタ/デストラクタプロトタイプ後の改行の数、
#別のコンストラクタ/デストラクタプロトタイプが続かない場合。
nl_after_func_class_proto_group = 0	#符号なしの数値

#クラス本体内の1行のメソッド定義を処理する必要があるかどうか
#改行を追加するためのプロトタイプであるかのように。
#
#nl_class_leave_one_liners = trueが必要です。nl_before_func_body_defをオーバーライドします
#およびワンライナーの場合はnl_before_func_class_def。
nl_class_leave_one_liner_groups = false	#true / false

#複数行の関数本体の「}」の後の改行の数。
nl_after_func_body = 0	#符号なしの数値

#クラス内の複数行の関数本体の「}」の後の改行の数
#宣言。クラスコンストラクタ/デストラクタにも影響します。
#
#nl_after_func_bodyをオーバーライドします。
nl_after_func_body_class = 0	#符号なしの数値

#1行の関数本体の「}」の後の改行の数。また
#クラスコンストラクタ/デストラクタに影響します。
#
#nl_after_func_bodyおよびnl_after_func_body_classをオーバーライドします。
nl_after_func_body_one_liner = 0	#符号なしの数値

#複数行コメントの前の改行の最小数。
#中括弧を開いた後、または別の複数行コメントの後の場合は適用されません。
nl_before_block_comment = 0	#符号なしの数値

#1行のCコメントの前の改行の最小数。
#中括弧を開いた後、または他の1行のCコメントの場合は適用されません。
nl_before_c_comment = 0	#符号なしの数値

#CPPコメントの前の改行の最小数。
#中括弧を開いた後、または他のCPPコメントの場合は適用されません。
nl_before_cpp_comment = 0	#符号なしの数値

#複数行コメントの後に改行を強制するかどうか。
nl_after_multiline_comment = false	#true / false

#ラベルのコロンの後に改行を強制するかどうか。
nl_after_label_colon = false	#true / false

#「}」または「;」の後の改行の数 構造体/列挙型/ユニオン定義の。
nl_after_struct = 0	#符号なしの数値

#クラス定義の前の改行の数。
nl_before_class = 0	#符号なしの数値

#「}」または「;」の後の改行の数 クラス定義の。
nl_after_class = 0	#符号なしの数値

#アクセス指定子ラベルの前の改行の数。これには、
#Qt固有の「シグナル：」および「スロット：」。改行数は変更されません
#ブレースを開いた後の場合。
#
#0 =変更なし（デフォルト）。
nl_before_access_spec = 0	#符号なしの数値

#アクセス指定子ラベルの後の改行の数。これには、
#Qt固有の「シグナル：」および「スロット：」。改行数は変更されません
#ブレースを開いた後の場合。
#
#0 =変更なし（デフォルト）。
#
#nl_typedef_blk_startとnl_var_def_blk_startをオーバーライドします。
nl_after_access_spec = 0	#符号なしの数値

#関数定義と関数の間の改行の数
#コメント、 ' //コメント\ n <ここ> void foo（）{...}'のように。
#
#0 =変更なし（デフォルト）。
nl_comment_func_def = 0	#符号なしの数値

#try-catch-finallyブロック後のフォローされていない改行の数
#中括弧で閉じます。
#
#0 =変更なし（デフォルト）。
nl_after_try_catch_finally = 0	#符号なしの数値

#（C	#）プロパティ、インデクサー、またはイベントの前後の改行の数
#宣言。
#
#0 =変更なし（デフォルト）。
nl_around_cs_property = 0	#符号なしの数値

#（C	#）get / set / add / removeハンドラー間の改行の数。
#
#0 =変更なし（デフォルト）。
nl_between_get_set = 0	#符号なしの数値

#（C	#）プロパティと '{'の間に改行を追加または削除します。
nl_property_brace = ignore	#ignore / add / remove / force

#名前空間の「{」の後の改行の数。これも改行を追加します
#一致する '}'の前。
#
#0 =次の場合、eat_blanks_after_open_braceまたはeat_blanks_before_close_braceを適用します
#該当する場合、それ以外は変更なし。
#
#eat_blanks_after_open_braceとeat_blanks_before_close_braceをオーバーライドします。
nl_inside_namespace = 0	#符号なし数値

# '{'の後の空白行を削除するかどうか。
eat_blanks_after_open_brace = false	#true / false

#「}」の前の空白行を削除するかどうか。
eat_blanks_before_close_brace = false	#true / false

#プリプロセッサにない余分な改行をどれだけ積極的に削除するか。
#
#0：変更なし（デフォルト）
#1：他の設定で処理されないほとんどの改行を削除する
#2：すべての改行を削除し、構成によって完全に再フォーマットします
nl_remove_extra_newlines = 0	#符号なしの数値

#開いた後でない限り、 'return'ステートメントの前に空白行を置くかどうか
#中括弧。
nl_before_return = false	#true / false

# 'return'ステートメントの後に空白行を置くかどうか
#中括弧を閉じます。
nl_after_return = false	#true / false

#（Java）注釈ステートメントの後に改行を追加または削除します。影響のみ
#改行の後にある注釈。
nl_after_annotation = ignore	#ignore / add / remove / force

#（Java）2つの注釈の間に改行を追加または削除します。
nl_between_annotation = ignore	#ignore / add / remove / force

#
#位置決めオプション
#

#ラップされた式での算術演算子の位置。
pos_arith = ignore	#ignore / break / force / Lead / trail / join / Lead_break / Lead_force / trail_break / trail_force

#ラップされた式での割り当ての位置。'='に影響を与えない
# に続く '{'。
pos_assign = ignore	#ignore / break / force / Lead / trail / join / Lead_break / Lead_force / trail_break / trail_force

#ラップされた式でのブール演算子の位置。
pos_bool = ignore	#ignore / break / force / Lead / trail / join / Lead_break / Lead_force / trail_break / trail_force

#ラップされた式での比較演算子の位置。
pos_compare = ignore	#ignore / break / force / Lead / trail / join / Lead_break / Lead_force / trail_break / trail_force

#「？」のような条件演算子の位置 および '：'の
# 'expr？stmt：stmt '、ラップされた式。
pos_conditional = ignore	#ignore / break / force / Lead / trail / join / Lead_break / Lead_force / trail_break / trail_force

#ラップされた式でのコンマの位置。
pos_comma = ignore	#ignore / break / force / Lead / trail / join / Lead_break / Lead_force / trail_break / trail_force

#列挙型エントリ内のコンマの位置。
pos_enum_comma = ignore	#ignore / break / force / Lead / trail / join / Lead_break / Lead_force / trail_break / trail_force

#複数ある場合の基本クラスリスト内のコンマの位置
#行。nl_class_init_argsに影響します。
pos_class_comma = ignore	#ignore / break / force / Lead / trail / join / Lead_break / Lead_force / trail_break / trail_force

#コンストラクタ初期化リスト内のコンマの位置。
#nl_constr_colon、nl_constr_init_args、およびpos_constr_colonに関連します。
pos_constr_comma = ignore	#ignore / break / force / Lead / trail / join / Lead_break / Lead_force / trail_break / trail_force

#クラスと基本クラスの間の、末尾/先頭のクラスコロンの位置
#リスト。nl_class_colonに影響します。
pos_class_colon = ignore	#ignore / break / force / Lead / trail / join / Lead_break / Lead_force / trail_break / trail_force

#コンストラクターとメンバーの初期化の間のコロンの位置。
#nl_constr_colon、nl_constr_init_args、およびpos_constr_commaに関連します。
pos_constr_colon = ignore	#ignore / break / force / Lead / trail / join / Lead_break / Lead_force / trail_break / trail_force

#
#行分割オプション
#

#コード幅をN列に制限してみてください。
code_width = 0	#符号なしの数値

#長い 'for'ステートメントをセミコロンで完全に分割するかどうか。
ls_for_split_full = false	#true / false

#長い関数プロトタイプ/呼び出しをコンマで完全に分割するかどうか。
ls_func_split_full = false	#true / false

#行を可能な限りcode_widthに近づけて分割し、一部を無視するかどうか
#グループ化。
ls_code_width = false	#true / false

#
#コード配置オプション（左側の列スペース/タブではありません）
#

#インデントしないタブを保持するかどうか。
align_keep_tabs = false	#true / false

#位置合わせにタブを使用するかどうか。
align_with_tabs = true	#true / false

#位置合わせ時に次のタブにぶつかるかどうか。
align_on_tabstop = false	#true / false

#数値を右揃えにするかどうか。
align_number_right = false	#true / false

#位置合わせに空白を不要にするかどうか。
align_keep_extra_space = false	#true / false

#プロトタイプと関数の変数定義を揃えるかどうか。
align_func_params = true	#true / false

#関数内のパラメーター定義をパラメーター名に合わせるためのスパン。
#
#0 =位置合わせしない（デフォルト）。
align_func_params_span = 0	#符号なし数値

#関数パラメーター定義を調整するためのしきい値。
#
#0 =制限なし（デフォルト）。
align_func_params_thresh = 0	#符号なしの数値

#関数パラメーター定義を整列させるためのギャップ。
align_func_params_gap = 0	#符号なしの数値

#同じものを持つ単一行関数のパラメーターを整列するかどうか
# 名前。関数名は、すでに相互に整列している必要があります。
align_same_func_call_params = false	#true / false

#単一行関数の関数呼び出しパラメーターを整列するためのスパン。
#
#0 =位置合わせしない（デフォルト）。
align_same_func_call_params_span = 0	#符号なしの数値

#単一行の関数呼び出しパラメーターを整列するためのしきい値
# 機能。
#
#0 =制限なし（デフォルト）。
align_same_func_call_params_thresh = 0	#符号なしの数値

#変数定義を整列するためのスパン。
#
#0 =位置合わせしない（デフォルト）。
align_var_def_span = 1	#符号なしの数値

#変数定義の「*」を揃える方法。
#
#0：タイプの一部 'void * foo;' （デフォルト）
#1：変数の一部 'void * foo;'
#2：ぶら下がり 'void * foo;'
align_var_def_star_style = 1	#符号なしの数値

#変数定義の「＆」を揃える方法。
#
#0：タイプ 'long＆foo;'の一部 （デフォルト）
#1：変数 'long＆foo;'の一部
#2：ぶら下がり '長い＆foo;'
align_var_def_amp_style = 0	#符号なしの数値

#変数定義を整列するためのしきい値。
#
#0 =制限なし（デフォルト）。
align_var_def_thresh = 0	#符号なしの数値

#変数定義を揃えるためのギャップ。
align_var_def_gap = 0	#符号なしの数値

#構造体ビットフィールドのコロンを揃えるかどうか。
align_var_def_colon = false	#true / false

#構造体ビットフィールドのコロンを揃えるためのギャップ。
align_var_def_colon_gap = 0	#符号なしの数値

#変数名の後に属性を揃えるかどうか。
align_var_def_attribute = false	#true / false

#インラインstruct / enum / union変数定義を整列するかどうか。
align_var_def_inline = false	#true / false

#割り当ての「=」に揃えるためのスパン。
#
#0 =位置合わせしない（デフォルト）。
align_assign_span = 1	#符号なしの数値

#割り当ての「=」に揃えるためのしきい値。
#
#0 =制限なし（デフォルト）。
align_assign_thresh = 0	#符号なしの数値

#関数宣言「割り当て」にalign_assign_spanを適用する方法。
# 'virtual void foo（）= 0'または '?foo（）= {default | delete}'。
#
#0：他の割り当てに合わせる（デフォルト）
#1：通常の割り当てを無視して、互いに整列します
#2：整列しない
align_assign_decl_func = 0	#符号なしの数値

#列挙型の「=」に整列するためのスパン。
#
#0 =位置合わせしない（デフォルト）。
align_enum_equ_span = 1	#符号なしの数値

#列挙型の「=」に揃えるためのしきい値。
#
#0 =制限なし（デフォルト）。
align_enum_equ_thresh = 0	#符号なしの数値

#クラスメンバー定義を整列するためのスパン。
#
#0 =位置合わせしない（デフォルト）。
align_var_class_span = 0	#符号なし数値

#クラスメンバー定義を調整するためのしきい値。
#
#0 =制限なし（デフォルト）。
align_var_class_thresh = 0	#符号なしの数値

#クラスメンバー定義を調整するためのギャップ。
align_var_class_gap = 0	#符号なしの数値

#構造体/共用体メンバー定義を整列するためのスパン。
#
#0 =位置合わせしない（デフォルト）。
align_var_struct_span = 2	#符号なしの数値

#構造体/共用体メンバー定義を整列させるためのしきい値。
#
#0 =制限なし（デフォルト）。
align_var_struct_thresh = 0	#符号なしの数値

#構造体/共用体メンバーの定義を揃えるためのギャップ。
align_var_struct_gap = 0	#符号なしの数値

#構造体初期化値を整列するためのスパン。
#
#0 =位置合わせしない（デフォルト）。
align_struct_init_span = 1	#符号なしの数値

#typeとtypedefのシノニムの間の最小スペース。
align_typedef_gap = 0	#符号なしの数値

#単一行のtypedefを整列するためのスパン。
#
#0 =位置合わせしない（デフォルト）。
align_typedef_span = 1	#符号なしの数値

#typedefされた関数を他のtypedefと整列させる方法。
#
#0：それらをまったく混ぜないでください（デフォルト）
#1：開き括弧をタイプに合わせます
#2：関数の型名を他の型名に合わせる
align_typedef_func = 0	#符号なし数値

#typedefの「*」を揃える方法。
#
#0：typedefタイプに揃え、 '*'を無視します（デフォルト）
#1： '*'は型名の一部です： 'typedef int * pint;'
#2： '*'は型の一部ですが、ぶら下がっています： 'typedef int * pint;'
align_typedef_star_style = 1	#符号なしの数値

#typedefの「＆」を揃える方法。
#
#0：typedefタイプに揃え、 '＆'を無視します（デフォルト）
#1： '＆'は型名の一部です： 'typedef int＆pint;'
#2： '＆'は型の一部ですが、ぶら下がっています： 'typedef int＆pint;'
align_typedef_amp_style = 0	#符号なしの数値

#行を終了するコメントを整列するためのスパン。
#
#0 =位置合わせしない（デフォルト）。
align_right_cmt_span = 3	#符号なしの数値

#コメントを揃える場合、「}」の後のコメントと混合するかどうか、	#endif with
#コメントの前に3スペース未満。
align_right_cmt_mix = false	#true / false

#同じ中括弧レベルにある末尾のコメントのみを整列するかどうか。
align_right_cmt_same_level = false	#true / false

#前のテキストと最後のコメントの間の最小列数
#コメントが整列される資格を得る順序。ゼロ以外である必要があります
# 効果。
align_right_cmt_gap = 16	#符号なしの数値

#末尾のコメントを揃える最小の列。あるコメント
#この列を超えて配置されますが、より少ない列に配置できます。
#「引き込まれる」可能性があります。
#
#0 =無視（デフォルト）。
align_right_cmt_at_col = 0	#符号なしの数値

#関数プロトタイプを整列させるためのスパン。
#
#0 =位置合わせしない（デフォルト）。
align_func_proto_span = 1	#符号なしの数値

#戻り値の型と関数名の間の最小ギャップ。
align_func_proto_gap = 0	#符号なしの数値

#関数プロトタイプを「operator」キーワードではなく「operator」キーワードに揃えるかどうか
#次のとおり。
align_on_operator = false	#true / false

#整列プロトタイプと変数宣言を混在させるかどうか。真であれば、
#align_func_proto_XXXオプションの代わりにalign_var_def_XXXオプションが使用されます。
align_mix_var_proto = false	#true / false

#単一行関数を関数プロトタイプと整列させるかどうか。
#align_func_proto_spanを使用します。
align_single_line_func = false	#true / false

#単一行関数の開き中括弧を揃えるかどうか。
#align_single_line_func = trueが必要です。align_func_proto_spanを使用します。
align_single_line_brace = false	#true / false

#align_single_line_braceのギャップ。
align_single_line_brace_gap = 0	#符号なしの数値

#（OC）Objective-Cメッセージの仕様を調整するためのスパン。
#
#0 =位置合わせしない（デフォルト）。
align_oc_msg_spec_span = 0	#符号なしの数値

#円記号と改行でラップされたマクロを整列するかどうか。この意志
#マクロに複数行のコメントが含まれている場合、正しく機能しません。
align_nl_cont = false	#true / false

#マクロ関数と変数を一緒に整列させるかどうか。
align_pp_define_together = false	#true / false

#プリプロセッサ定義のラベルと値の間の最小スペース。
align_pp_define_gap = 0	#符号なしの数値

#「	#define」ボディに位置合わせするためのスパン。
#
#= 0：位置合わせしない（デフォルト）
#> 0：ブロック間の行数（コメントを含む）
align_pp_define_span = 1	#符号なしの数値

#「<<」で始まる行を前の「<<」に揃えるかどうか。
#
#デフォルト：true
align_left_shift = true	#true / false

# 'asm volatile（）'コロンの後にテキストを揃えるかどうか。
align_asm_colon = false	#true / false

#（OC）Objective-Cメッセージ呼び出しでパラメーターを調整するためのスパン
#「：」に。
#
#0 =整列しません。
align_oc_msg_colon_span = 0	#符号なしの数値

#（OC）最初のパラメーターが多すぎる場合でも、常に最初のパラメーターと整列するかどうか
#短い。
align_oc_msg_colon_first = false	#true / false

#（OC）Objective-C '+'または '-'宣言のパラメーターを揃えるかどうか
#「：」に。
align_oc_decl_colon = false	#true / false

#
#コメント変更オプション
#

#コメントをN列で折り返すようにしてください。
cmt_width = 0	#符号なし数値

#コメントをリフローする方法。
#
#0：リフローなし（cmt_widthによる行の折り返しを除く）（デフォルト）
#1：まったく触れない
#2：フルリフロー
cmt_reflow_mode = 0	#符号なしの数値

#すべてのタブをコメント内のスペースに変換するかどうか。falseの場合、タブ
#インデントに使用しない限り、コメントはそのままにしておきます。
cmt_convert_tab_to_spaces = false	#true / false

#cmt_widthを含む複数行コメントに変更を適用するかどうか、
#キーワード置換と先頭文字。
#
#デフォルト：true
cmt_indent_multi = true	#true / false

#ブロック内にあるように見えるcコメントをグループ化するかどうか。
cmt_c_group = false	#true / false

#結合されたcコメントの最初の行に空の「/*」を配置するかどうか。
cmt_c_nl_start = false	#true / false

#結合されたcコメントの終了 '*/'の前に改行を追加するかどうか。
cmt_c_nl_end = false	#true / false

#cpp-commentsをc-commentsに変更するかどうか。
cmt_cpp_to_c = false	#true / false

#ブロック内にあるように見えるcppコメントをグループ化するかどうか。のみ
#cmt_cpp_to_c = trueの場合に意味があります。
cmt_cpp_group = false	#true / false

#結合されたcpp-commentの最初の行に空の「/*」を配置するかどうか
#cコメントに変換する場合。
#
#cmt_cpp_to_c = trueおよびcmt_cpp_group = trueが必要です。
cmt_cpp_nl_start = false	#true / false

#結合されたcpp-commentの終了 '*/'の前に改行を追加するかどうか
#cコメントに変換する場合。
#
#cmt_cpp_to_c = trueおよびcmt_cpp_group = trueが必要です。
cmt_cpp_nl_end = false	#true / false

#後続のコメント行にスターを付けるかどうか。
cmt_star_cont = false	#true / false

#後続のコメント行の先頭に挿入するスペースの数。
cmt_sp_before_star_cont = 0	#符号なしの数値

#後続のコメント行のスターの後に挿入するスペースの数。
cmt_sp_after_star_cont = 0	#符号なしの数値

#「*」で始まる複数行のコメントの場合、最初の場合は先頭のスペースを削除します
#とコメントの最後の行は同じ長さです。
#
#デフォルト：true
cmt_multi_check_last = true	#true / false

#「*」で始まる複数行のコメントの場合、最初の場合は先頭のスペースを削除します
#とコメントの最後の行は同じ長さであり、長さが
#first_lenの最小値よりも大きい。
#
#デフォルト：4
cmt_multi_first_len_minimum = 4	#符号なしの数値

#ファイルの先頭に挿入するテキストを含むファイルへのパス
#ファイルはC / C ++コメントで始まりません。挿入されたテキストにが含まれている場合
# '$（filename）'、これは現在のファイルの名前に置き換えられます。
cmt_insert_file_header = ""	#文字列

#ファイルの最後に挿入するテキストを含むファイルへのパス
#ファイルはC / C ++コメントで終わっていません。挿入されたテキストにが含まれている場合
# '$（filename）'、これは現在のファイルの名前に置き換えられます。
cmt_insert_file_footer = ""	#文字列

#関数定義の前に挿入するテキストを含むファイルへのパス
#関数の前にC / C ++コメントがありません。挿入されたテキストの場合
# '$（function）'、 '$（javaparam）'または '$（fclass）'が含まれ、これらは
#それぞれ、関数の名前javadoc '@ param'に置き換えられます
#および '@return'のもの、またはメンバー関数の対象となるクラスの名前
#所属します。
cmt_insert_func_header = ""	#文字列

#クラスの場合、クラスの前に挿入するテキストを含むファイルへのパス
#の前にC / C ++コメントはありません。挿入されたテキストに「$（class）」が含まれている場合、
#クラス名に置き換えられます。
cmt_insert_class_header = ""	#文字列

#Objective-Cメッセージの前に挿入するテキストを含むファイルへのパス
#指定。メソッドの前にC / C ++コメントがない場合。の場合
#挿入されたテキストには「$（メッセージ）」または「$（javaparam）」が含まれます。これらは次のようになります。
#それぞれ、関数の名前またはjavadocに置き換えられます
# '@ param'および '@return'のもの。
cmt_insert_oc_msg_header = ""	#文字列

#プリプロセッサが検出された場合にコメントを挿入する必要があるかどうか
#関数名から逆方向にステップします。
#
#cmt_insert_oc_msg_header、cmt_insert_func_header、およびに適用されます
#cmt_insert_class_header。
cmt_insert_before_preproc = false	#true / false

#関数がインラインで宣言されている場合にコメントを挿入する必要があるかどうか
#クラス定義。
#
#cmt_insert_func_headerに適用されます。
#
#デフォルト：true
cmt_insert_before_inlines = true	#true / false

#関数がクラスコンストラクターの場合にコメントを挿入するかどうか
#またはデストラクタ。
#
#cmt_insert_func_headerに適用されます。
cmt_insert_before_ctor_dtor = false	#true / false

#
#コード変更オプション（空白以外）
#

#1行の「do」ステートメントで中括弧を追加または削除します。
mod_full_brace_do = ignore	#ignore / add / remove / force

#1行の 'for'ステートメントで中括弧を追加または削除します。
mod_full_brace_for = ignore	#ignore / add / remove / force

#（ポーン）1行の関数定義で中括弧を追加または削除します。
mod_full_brace_function = ignore	#ignore / add / remove / force

#1行の 'if'ステートメントで中括弧を追加または削除します。中括弧はありません
#中括弧で囲まれたステートメントに「else」が含まれている場合は削除されます。
mod_full_brace_if = ignore	#ignore / add / remove / force

#「if」/「elseif」/「else」チェーンのすべてのブロックを強制するかどうか
#中括弧がある、またはない。trueの場合、ブロックがある場合は中括弧が追加されます
#中かっこが必要で、すべてから削除できる場合にのみ削除されます
#ブロック。
#
#mod_full_brace_ifをオーバーライドします。
mod_full_brace_if_chain = false	#true / false

#「if」/「elseif」/「else」チェーンのすべてのブロックに中括弧を追加するかどうか。
#trueの場合、mod_full_brace_if_chainは 'if'から中括弧のみを削除します。
#「elseif」または「else」はありません。
mod_full_brace_if_chain_only = false	#true / false

#1行の 'while'ステートメントで中括弧を追加または削除します。
mod_full_brace_while = ignore	#ignore / add / remove / force

#1行の 'using（）'ステートメントで中括弧を追加または削除します。
mod_full_brace_using = ignore	#ignore / add / remove / force

#N個の改行にまたがるステートメントを中括弧で囲まないでください
mod_full_brace_nl = 0	#符号なしの数値

# 'if' / 'for' / 'while' / etcから中括弧が削除されないようにするかどうか。ブロック
#複数行にまたがる。
#
#影響：
#mod_full_brace_for
#mod_full_brace_if
#mod_full_brace_if_chain
#mod_full_brace_if_chain_only
#mod_full_brace_while
#mod_full_brace_using
#
#影響しません：
#mod_full_brace_do
#mod_full_brace_function
mod_full_brace_nl_block_rem_mlcond = false	#true / false

#「return」ステートメントに不要な括弧を追加または削除します。
mod_paren_on_return = ignore	#ignore / add / remove / force

#（ポーン）オプションのセミコロンを実際のセミコロンに変更するかどうか。
mod_pawn_semicolon = false	#true / false

# 'while'および 'if'でブール式を完全に括弧で囲むかどうか
#ステートメント、 'if（a && b> c）'竊 'if（a &&（b> c）） 'のように。
mod_full_paren_if_bool = false	#true / false

#余分なセミコロンを削除するかどうか。
mod_remove_extra_semicolon = false	#true / false

#関数本体が指定された改行数を超えていない場合
#閉じ括弧の後にコメント、コメントが追加されます。
mod_add_long_function_closebrace_comment = 0	#符号なしの数値

#名前空間本体が指定された改行数を超えていない場合
#閉じ括弧の後にコメントがある場合、コメントが追加されます。
mod_add_long_namespace_closebrace_comment = 0	#符号なしの数値

#クラス本体が指定された改行数を超えており、
#閉じ括弧の後にコメント、コメントが追加されます。
mod_add_long_class_closebrace_comment = 0	#符号なしの数値

#スイッチ本体が指定された改行数を超えており、
#閉じ括弧の後にコメント、コメントが追加されます。
mod_add_long_switch_closebrace_comment = 0	#符号なしの数値

#	# ifdef本文が指定された改行数を超えていない場合
#endifの後に	#コメント、コメントが追加されます。
mod_add_long_ifdef_endif_comment = 0	#符号なしの数値

#	# ifdefまたは	#else本体が指定された改行数を超え、
#elseの後にコメントがない場合、コメントが追加されます。
mod_add_long_ifdef_else_comment = 0	#符号なしの数値

#連続する単一行の「import」ステートメントをソートするかどうか。
mod_sort_import = false	#true / false

#（C	#） 'using'ステートメントを使用して連続する単一行をソートするかどうか。
mod_sort_using = false	#true / false

#連続する単一行の「	#include」ステートメントをソートするかどうか（C / C ++）および
# '	#import'ステートメント（Objective-C）。これには次の可能性があることに注意してください
#インクルード/インポートに順序の依存関係がある場合は、コードを中断します。
mod_sort_include = false	#true / false

#完全にブレースされた「ケース」の後に表示される「ブレーク」を前に移動するかどうか
# 'case X：{...} break;'のように、中括弧を閉じます。竊  'ケースX：{...break;} '。
mod_move_case_break = false	#true / false

#完全に中括弧で囲まれたcaseステートメントの前後に中括弧を追加または削除します。削除するだけです
#ブロックに変数宣言がない場合は中括弧。
mod_case_brace = ignore	#ignore / add / remove / force

#voidを削除するかどうか 'return;' の最後のステートメントとして表示されます
# 関数。
mod_remove_empty_return = false	#true / false

#列挙型の最後の値の後にコンマを追加または削除します。
mod_enum_last_comma = ignore	#ignore / add / remove / force

#（OC）プロパティを整理するかどうか。trueの場合、プロパティは
#mod_sort_oc_property _ * _weight係数に従って再配置されます。
mod_sort_oc_properties = false	#true / false

#（OC）クラスプロパティ修飾子の重み。
mod_sort_oc_property_class_weight = 0	#数値

#（OC）「アトミック」と「非アトミック」の重み。
mod_sort_oc_property_thread_safe_weight = 0	#数値

#（OC）プロパティを整理するときの「readwrite」の重み。
mod_sort_oc_property_readwrite_weight = 0	#数値

#（OC）参照型指定子の重み（ 'retain'、 'copy'、 'assign'、
# '弱い'、 '強い'）プロパティを整理するとき。
mod_sort_oc_property_reference_weight = 0	#数値

#（OC）プロパティを整理するときのゲッタータイプ（ 'getter ='）の重み。
mod_sort_oc_property_getter_weight = 0	#数値

#（OC）プロパティを整理するときのセッタータイプ（ 'setter ='）の重み。
mod_sort_oc_property_setter_weight = 0	#数値

#（OC）null許容型の重み（ 'nullable'、 'nonnull'、 'null_unspecified'、
# 'null_resettable'）プロパティを整理するとき。
mod_sort_oc_property_nullability_weight = 0	#数値

#
#プリプロセッサオプション
#

#	# ifブロック内のプリプロセッサディレクティブのインデントを追加または削除します
#中括弧レベル0（ファイルレベル）。
pp_indent = ignore	#ignore / add / remove / force

#中括弧レベルで	#if /	#else /	#endifをインデントするかどうか。falseの場合、これらは
#列1からインデントされます。
pp_indent_at_level = false	#true / false

#レベルごとにプリプロセッサをインデントする列の数を指定します
#中括弧レベル0（ファイルレベル）。pp_indent_at_level = falseの場合、
#レベルごとにプリプロセッサをインデントする列の数
#ブレースレベル> 0（機能レベル）。
#
#デフォルト：1
pp_indent_count = 1	#符号なしの数値

#ifブロックのpp_levelに基づいて、	#後にスペースを追加または削除します。
pp_space = ignore	#ignore / add / remove / force

#pp_spaceで追加されるレベルごとのスペースの数を設定します。
pp_space_count = 0	#符号なしの数値

#C	#の「	#region」と「	#endregion」および「	#pragmaregion」のインデント
#C / C ++。負の値は、最初の列までインデントを減らします。
pp_indent_region = 0	#数値

#コードを	#regionと	#endregionの間でインデントするかどうか。
pp_region_indent_code = false	#true / false

#pp_indent_at_level = trueの場合、	#if、	#else、および	#endifのインデントを設定します。
#ファイルレベルではありません。負の値は、最初の列までインデントを減らします。
#
#= 0：output_tab_sizeを使用してプリプロセッサをインデントします
#> 0：すべてのプリプロセッサがインデントされる列
pp_indent_if = 0	#数値

#コードを	#if、	#else、	#endifの間でインデントするかどうか。
pp_if_indent_code = false	#true / false

#中括弧レベルで「	#define」をインデントするかどうか。falseの場合、これらは
#列1からインデントされます。
pp_define_at_level = false	#true / false

#フォーマット中に「	#define」本文を無視するかどうか。
pp_ignore_define_body = false	#true / false

#caseステートメントを	#if、	#else、	#endifの間でインデントするかどうか。
#caseステートメントの前処理プログラムのインデントにのみ適用されます
#直接内部。
#
#デフォルト：true
pp_indent_case = true	#true / false

#関数定義全体を	#if、	#else、	#endifの間でインデントするかどうか。
#関数定義が前処理プログラムのインデントにのみ適用されます
#は直接内部にあります。
#
#デフォルト：true
pp_indent_func_def = true	#true / false

#extern Cブロックを	#if、	#else、および	#endifの間でインデントするかどうか。
#externブロックがである前処理者のインデントにのみ適用されます
#直接内部。
#
#デフォルト：true
pp_indent_extern = true	#true / false

#中括弧を	#if、	#else、および	#endifの内部に直接インデントするかどうか。
#中括弧が直接ある前処理プログラムのインデントにのみ適用されます
# の中に。
#
#デフォルト：true
pp_indent_brace = true	#true / false

#
#並べ替えにはオプションが含まれます
#

#優先度0のインクルードカテゴリの正規表現。
include_category_0 = ""	#文字列

#優先度1のインクルードカテゴリの正規表現。
include_category_1 = ""	#文字列

#優先度2のインクルードカテゴリの正規表現。
include_category_2 = ""	#文字列

#
#使用するまたは使用しないオプション
#

#true：indent_func_call_paramが使用されます（デフォルト）
#false：indent_func_call_paramは使用されません
#
#デフォルト：true
use_indent_func_call_param = true	#true / false

#継続行のインデントの値が計算されます
#ステートメントが次の場合は異なります：
#-宣言：QStringfileNameの場合..。
#-割り当て：pSettings = new QSettings（..。
#
#2番目のケースでは、インデント値が2回使用される可能性があります。
#-割り当て時
#-関数呼び出し時（存在する場合）
#
#インデント値の二重使用を防ぐには、このオプションを
#値 'true'。
#
#true：indent_continueは1回だけ使用されます
#false：indent_continueは毎回使用されます（デフォルト）
use_indent_continue_only_once = false	#true / false

#値は2回使用される可能性があります：
#-割り当て時
#-オープニングブレースで
#
#インデント値の二重使用を防ぐには、このオプションを
#値 'true'。
#
#true：インデントは1回だけ使用されます
#false：インデントは毎回使用されます（デフォルト）
indent_cpp_lambda_only_once = true	#true / false

#Qt SIGNAL / SLOTマクロに特別なフォーマットを適用するかどうか。基本的に、
#これは、Qtの正規化された形式と一致するようにこれらをフォーマットしようとします（つまり、
#QMetaObject : : normalizedSignatureの結果）、これにより、
#QObject : : connect呼び出しのパフォーマンス（方法ではなく）
#それ以外の場合はフォーマットされます。
#
#詳細については、options_for_QT.cppを参照してください。
#
#デフォルト：true
use_options_overriding_for_qt_macros = true	#true / false

#
#警告レベル-1：エラー、2：警告（デフォルト）、3：注意
#

#（C	#）タブから\ tへの置き換えを行っているときに警告が表示され、1つが見つかりました
#C	#の逐語的な文字列リテラル。
#
#デフォルト：2
warn_level_tabs_found_in_verbatim_string_literals = 2 	# 符号なしの数値

#設定の意味：
#無視-変更を加えない
#追加-1つ以上のスペース/中括弧/改行などがあることを確認します
#強制-スペース/中括弧/改行などが正確に1つあることを確認します。
#一部のコンテキストではAddのように動作します
#削除-スペース/中括弧/改行などを削除します
#
#
#-トークンは、「set」オプションを使用して特定のタイプとして扱うことができます。
# `set tokenType tokenString [tokenString ...]`
#
#例：
# `set BOOL __AND__ __OR__`
#
#tokenTypesはsrc / token_enum.hで定義されており、
# 'CT_'プレフィックス： 'CT_BOOL'竊 'BOOL '
#
#
#-トークンは、「type」オプションを使用してタイプとして扱うことができます。
# `type tokenString [tokenString ...]`
#
#例：
# `type int c_uint_8 Rectangle`
#
#これは、 `set TYPE int c_uint_8Rectangle`でも実現できます。
#
#
#tokenStringsに空白を埋め込むには、「\」エスケープ文字を使用するか、引用符を使用します
#tokenStrings。これらの引用符はサポートされています： "'`
#
#
#-ファイルの末尾を介した言語の自動検出のサポートは、
#「file_ext」コマンドを使用して追加。
# `file_ext langType langString [langString ..
																																											]`
#
#例：
# `file_ext CPP .ch .cxx .cpp.in`
#
#langTypesは、lang_flag_e列挙型のuncrusify_types.hで定義されています。
#「LANG_」プレフィックスなしのそれら：「LANG_CPP」竊 「CPP」
#
#
#-カスタムマクロベースのインデントは、「macro-open」を使用して設定できます。
# 'macro-else'および 'macro-close'。
# `（macro-open | macro-else | macro-close）tokenString`
#
#例：
# `マクロオープンBEGIN_TEMPLATE_MESSAGE_MAP`
# `マクロオープンBEGIN_MESSAGE_MAP`
# `マクロクローズEND_MESSAGE_MAP`
#
#
#「デフォルトではない」値のオプション：1
#